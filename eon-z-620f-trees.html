<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__eo) {
  // .................. eons
  let [
    ctlWen,
    eohalMars,
    eohalSol,
    muonProps,
    renderSvg,
  ] = await Promise.all([
    __eo('xs').c('wen'),
    __eo('xs').e('mars'),
    __eo('xs').e('sol'),
    __eo('xs').m('props'),
    __eo('xs').r('svg'),
  ])

  let muonStore = __eo('muonStore')

  // .................. animas
  let ani = function () {
    // .................. pics
    let eotim = {'td': 3800, 't0': 0, 't1': 1, 't2': 1, 't3': 1}

    // .................. getNewFeature
    let getNewFeature = function (feature, props, i) {
      let { growunit, baseangle, depth, maxDepth, branchWidt, branchColor, maxAngleDelta, directions, eocrom, shrinkage, colordelta, subgrow, subgrowunit, subdirections, subangfact, subShrinkage } = props

      let linesInNewFeature = []

      let linesInFeature = feature.geometry.coordinates
      for (let j = 0; j < linesInFeature.length; j++) {
        let lineInFeature = linesInFeature[j]

        for (let k = 0; k < directions.length; k++) { // split
          let direction = directions[k]

          let nodesInLine = lineInFeature.length
          console.assert(nodesInLine >= 2, `error in line ${lineInFeature}`)

          let x1 = lineInFeature[nodesInLine - 1][0]
          let y1 = lineInFeature[nodesInLine - 1][1]

          let inang = baseangle

          let dirAngle = inang + maxAngleDelta * Math.random() * direction
          let dirLength = growunit * (Math.pow(shrinkage, i) + Math.random() * Math.pow((1.0 - shrinkage), i))

          const x2 = x1 + dirLength * Math.cos(dirAngle)
          const y2 = y1 + dirLength * Math.sin(dirAngle)

          let lineInNewFeature = [ [x1, y1], [x2, y2] ]
          linesInNewFeature.push(lineInNewFeature)
        }
      }

      let neweocrom = muonProps.clone(eocrom) // eocrom //
      neweocrom.cs = eocrom.cs + colordelta * i
      neweocrom.cw = eocrom.cw * Math.pow(shrinkage, i)

      let newFeature = {
        type: 'Feature',
        geometry: {
          type: 'MultiLineString',
          coordinates: linesInNewFeature,
        },
        properties: {
          eocrom: neweocrom,
        },
      }

      return newFeature
    }

    // .................. updFeature
    let updFeature = function (feature, props, i) {
      let { growunit, baseangle, depth, maxDepth, branchWidt, branchColor, maxAngleDelta, directions, eocrom, shrinkage, colordelta, subgrow, subgrowunit, subdirections, subangfact, subShrinkage } = props

      let linesInFeature = muonProps.clone(feature.geometry.coordinates)
      let linesInNewFeature = []

      for (let j = 0; j < linesInFeature.length; j++) {
        let lineInFeature = linesInFeature[j]

        for (let k = 0; k < subdirections.length; k++) { // split
          let direction = subdirections[k]

          let nodesInLine = lineInFeature.length
          console.assert(nodesInLine >= 2, `error in line ${lineInFeature}`)

          let x0 = lineInFeature[nodesInLine - 2][0]
          let y0 = lineInFeature[nodesInLine - 2][1]

          let x1 = lineInFeature[nodesInLine - 1][0]
          let y1 = lineInFeature[nodesInLine - 1][1]

          let inang = Math.atan2(y1 - y0, x1 - x0)
          let maxAngleDelta = Math.PI / subangfact

          let dirAngle = inang + maxAngleDelta * Math.random() * direction

          let dirLength = subgrowunit * (Math.pow(subShrinkage, i) + Math.random() * Math.pow((1.0 - subShrinkage), i))

          const x2 = x1 + dirLength * Math.cos(dirAngle)
          const y2 = y1 + dirLength * Math.sin(dirAngle)

          let updlines = [...lineInFeature, [x2, y2]]

          linesInFeature[j] = updlines
        }
      }
      let updfeature = muonProps.clone(feature)
      updfeature.geometry.coordinates = linesInFeature
      return updfeature
    }

    // .................. buildBranch - from branch end build new branch
    const buildTree = (tree, props) => {
      let { growunit, baseangle, depth, maxDepth, branchWidt, branchColor, maxAngleDelta, directions, eocrom, shrinkage, colordelta, subgrow, subgrowunit, subdirections, subangfact, subShrinkage } = props

      let step = Math.floor(depth) // growth orbital

      let treeFeatures = tree.features
      let qFeatures = treeFeatures.length

      let newFeatures = treeFeatures // tree gens to newTree gens

      for (let i = 0; i < qFeatures; i++) { // each gen :: feature
        if (step >= qFeatures) { // if ste is in or above generation
          let feature = treeFeatures[i]

          let newFeature = getNewFeature(feature, props, i)

          newFeatures = [...treeFeatures, newFeature]
        } // split
      } // gen

      if (subgrow === 1 && step < newFeatures.length) {
        let feature = newFeatures[step]

        let updfeature = updFeature(feature, props, step)

        newFeatures[step] = updfeature
      }

      let newTree = {
        type: 'FeatureCollection',
        features: newFeatures,
      }
      return newTree
    }

    // .................. treeAni1
    let treeAni1 = {

      eohal: 'mars',
      eotim: eotim,
      eoric: { gid: 'ani', cid: 'ani', fid: 'ani1'},

      eofold: ani => {
        let eoload = ani.eoload
        let eocrom = ani.eocrom

        const props = eoload.tree.props,
          x0 = eoload.tree.x0,
          y0 = eoload.tree.y0,
          growunit = eoload.tree.props.growunit,
          baseangle = eoload.tree.props.baseangle

        props.eocrom = eocrom
        // let feature = {
        // type: 'Feature',
        // geometry: { type: 'MultiLineString', coordinates: [] },
        // properties: {},
        // }

        // const maxDepth = eoload.tree.maxDepth,
        // depth = eoload.tree.depth,
        // trunkWidth = eoload.tree.trunkWidth,
        // branchColor = eoload.tree.branchColor,
        // grounit = eoload.tree.grounit0,
        // angle = eoload.tree.angle0,
        // x0 = eoload.tree.x0,
        // y0 = eoload.tree.y0,
        // branchShrinkage = eoload.tree.branchShrinkage,
        // maxAngleDelta = eoload.tree.maxAngleDelta,
        // directions = eoload.tree.directions

        let uidPreitem = ani.eoric.uid
        let preAnigram = uidPreitem ? muonStore.findAnigramFromUid(uidPreitem) : null
        let tree
        if (preAnigram) {
          tree = preAnigram.eofold
        } else {
          // ent >
          let x1 = x0
          let y1 = y0
          let x2 = x1 + growunit * Math.cos(baseangle)
          let y2 = y1 + growunit * Math.sin(baseangle)
          let linesInFeature = Array.of([ [x1, y1], [x2, y2] ])
          let stemFeature = {
            type: 'Feature',
            geometry: {
              type: 'MultiLineString',
              coordinates: linesInFeature,
            },
            properties: {},
          }
          // ent <

          let features = Array.of(stemFeature)
          tree = {
            type: 'FeatureCollection',
            features: features,
            properties: {},
          }
        }
        let newtree = buildTree(tree, props)

        return newtree
      },

      eocrom: {csx: 3, cf: 555, cs: 111, cw: 6.9, co: 0.0072, cp: 0.99},

      eoload: {
        tree: {
          x0: -140, y0: -160,
          props: {
            baseangle: Math.PI / 2, // start angle

            depth: [[[0, 12]]], // depth iter

            growunit: 2, // rate of feature growth in tick
            maxAngleDelta: Math.PI / 2, // max abs ang delta
            directions: [ -1, 1 ], // deviations

            shrinkage: 0.9, // size shrink
            colordelta: 100, // color delta between gens

            subgrow: 1, // inside growth
            subgrowunit: 2, // rate of feature growth in tick
            subangfact: 6, // width of secondary deviation
            subdirections: [0.1], // direction in stems
            subShrinkage: 0.9, // size shrink

            trunkWidth: 12, // initial ent size
            branchColor: [101, 67, 33], // --
            maxDepth: 8, // --
            delay: 10, // --
          },

          // grounit0: 2, // 60,
          // angle0: Math.PI / 2,

          // directions: [-2, 2],
          // maxDepth: 8,
          // depth: [[[0, 12]]],
          // trunkWidth: 12,
          // branchColor: [101, 67, 33],
          // branchShrinkage: 0.9,
          // maxAngleDelta: Math.PI / 2,
          // delay: 10,

        },
      },
    }

    // .................. treeAni2
    let treeAni2 = {

      eohal: 'mars',
      eotim: eotim,
      eoric: { gid: 'ani', cid: 'ani', fid: 'ani2'},

      eofold: ani => {
        let eoload = ani.eoload
        let eocrom = ani.eocrom

        const props = eoload.tree.props,
          x0 = eoload.tree.x0,
          y0 = eoload.tree.y0,
          growunit = eoload.tree.props.growunit,
          baseangle = eoload.tree.props.baseangle

        props.eocrom = eocrom

        // let feature = {
        // type: 'Feature',
        // geometry: { type: 'MultiLineString', coordinates: [] },
        // properties: {},
        // }

        // const maxDepth = eoload.tree.maxDepth,
        // depth = eoload.tree.depth,
        // trunkWidth = eoload.tree.trunkWidth,
        // branchColor = eoload.tree.branchColor,
        // grounit = eoload.tree.grounit0,
        // angle = eoload.tree.angle0,
        // x0 = eoload.tree.x0,
        // y0 = eoload.tree.y0,
        // branchShrinkage = eoload.tree.branchShrinkage,
        // maxAngleDelta = eoload.tree.maxAngleDelta,
        // directions = eoload.tree.directions

        let uidPreitem = ani.eoric.uid
        let preAnigram = uidPreitem ? muonStore.findAnigramFromUid(uidPreitem) : null
        let tree
        if (preAnigram) {
          tree = preAnigram.eofold
        } else {
          // ent >
          let x1 = x0
          let y1 = y0
          let x2 = x1 + growunit * Math.cos(baseangle)
          let y2 = y1 + growunit * Math.sin(baseangle)
          let linesInFeature = Array.of([ [x1, y1], [x2, y2] ])
          let stemFeature = {
            type: 'Feature',
            geometry: {
              type: 'MultiLineString',
              coordinates: linesInFeature,
            },
            properties: {},
          }
          // ent <

          let features = Array.of(stemFeature)
          tree = {
            type: 'FeatureCollection',
            features: features,
            properties: {},
          }
        }
        let newtree = buildTree(tree, props)

        return newtree
      },

      eocrom: {csx: 2, cf: 555, cs: 111, cw: 6.9, co: 0.0072, cp: 0.99},

      eoload: {
        tree: {
          x0: 0, y0: -80,

          props: {
            baseangle: Math.PI / 2, // start angle

            depth: [[[0, 12]]], // depth iter

            growunit: 2, // rate of feature growth in tick
            maxAngleDelta: Math.PI / 2, // max abs ang delta
            directions: [ -1, 1 ], // deviations

            shrinkage: 0.9, // size shrink
            colordelta: 100, // color delta between gens

            subgrow: 1, // inside growth
            subgrowunit: 2, // rate of feature growth in tick
            subangfact: 6, // width of secondary deviation
            subdirections: [0.1], // direction in stems
            subShrinkage: 0.9, // size shrink

            trunkWidth: 12, // initial ent size
            branchColor: [101, 67, 33], // --
            maxDepth: 8, // --
            delay: 10, // --
          },

          // grounit0: 2, // 60,
          // angle0: Math.PI / 2,

          // directions: [-2, 2],
          // maxDepth: 8,
          // depth: [[[0, 12]]],
          // trunkWidth: 12,
          // branchColor: [101, 67, 33],
          // branchShrinkage: 0.9,
          // maxAngleDelta: Math.PI / 2,
          // delay: 10,

        },
      },
    }

    // .................. treeAni3
    let treeAni3 = {

      eohal: 'mars',
      eotim: eotim,
      eoric: { gid: 'ani', cid: 'ani', fid: 'ani3'},

      eofold: ani => {
        let eoload = ani.eoload
        let eocrom = ani.eocrom

        const props = eoload.tree.props,
          x0 = eoload.tree.x0,
          y0 = eoload.tree.y0,
          growunit = eoload.tree.props.growunit,
          baseangle = eoload.tree.props.baseangle

        props.eocrom = eocrom
        // let feature = {
        // type: 'Feature',
        // geometry: { type: 'MultiLineString', coordinates: [] },
        // properties: {},
        // }

        // const maxDepth = eoload.tree.maxDepth,
        // depth = eoload.tree.depth,
        // trunkWidth = eoload.tree.trunkWidth,
        // branchColor = eoload.tree.branchColor,
        // grounit = eoload.tree.grounit0,
        // angle = eoload.tree.angle0,
        // x0 = eoload.tree.x0,
        // y0 = eoload.tree.y0,
        // branchShrinkage = eoload.tree.branchShrinkage,
        // maxAngleDelta = eoload.tree.maxAngleDelta,
        // directions = eoload.tree.directions

        let uidPreitem = ani.eoric.uid
        let preAnigram = uidPreitem ? muonStore.findAnigramFromUid(uidPreitem) : null
        let tree
        if (preAnigram) {
          tree = preAnigram.eofold
        } else {
          // ent >
          let x1 = x0
          let y1 = y0
          let x2 = x1 + growunit * Math.cos(baseangle)
          let y2 = y1 + growunit * Math.sin(baseangle)
          let linesInFeature = Array.of([ [x1, y1], [x2, y2] ])
          let stemFeature = {
            type: 'Feature',
            geometry: {
              type: 'MultiLineString',
              coordinates: linesInFeature,
            },
            properties: {},
          }
          // ent <

          let features = Array.of(stemFeature)
          tree = {
            type: 'FeatureCollection',
            features: features,
            properties: {},
          }
        }
        let newtree = buildTree(tree, props)

        return newtree
      },

      eocrom: {csx: 3, cf: 555, cs: 111, cw: 6.9, co: 0.0072, cp: 0.99},

      eoload: {
        tree: {
          x0: 100, y0: -20,
          props: {
            baseangle: Math.PI / 2, // start angle

            depth: [[[0, 12]]], // depth iter

            growunit: 2, // rate of feature growth in tick
            maxAngleDelta: Math.PI / 2, // max abs ang delta
            directions: [ -1, 1 ], // deviations

            shrinkage: 0.9, // size shrink
            colordelta: 100, // color delta between gens

            subgrow: 1, // inside growth
            subgrowunit: 2, // rate of feature growth in tick
            subangfact: 6, // width of secondary deviation
            subdirections: [0.1], // direction in stems
            subShrinkage: 0.9, // size shrink

            trunkWidth: 12, // initial ent size
            branchColor: [101, 67, 33], // --
            maxDepth: 8, // --
            delay: 10, // --
          },

          // grounit0: 2, // 60,
          // angle0: Math.PI / 2,

          // directions: [-2, 2],
          // maxDepth: 8,
          // depth: [[[0, 12]]],
          // trunkWidth: 12,
          // branchColor: [101, 67, 33],
          // branchShrinkage: 0.9,
          // maxAngleDelta: Math.PI / 2,
          // delay: 10,

        },
      },
    }

    // .................. animas
    let animas = [

      treeAni1, // h.mars
      treeAni2, // h.mars
      treeAni3, // h.mars

    ]

    return animas
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>
