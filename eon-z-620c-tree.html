<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__mapper) {
  // .................. eons
  let [
    ctlWen,
    eohalMars,
    eohalSol,
    eohalScene,
  ] = await Promise.all([
    __mapper('xs').c('wen'),
    __mapper('xs').e('mars'),
    __mapper('xs').e('sol'),
    __mapper('xs').e('scene'),
  ])

  let muonStore = __mapper('muonStore')

  // .................. animas
  let ani = function () {
    // .................. pics
    let eotim = {'td': 3800, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}

    function shadeRGBColor (color, percent) {
      var f = color.split(','),
        t = percent < 0 ? 0 : 255,
        p = percent < 0 ? percent * -1 : percent,
        R = parseInt(f[0].slice(4)),
        G = parseInt(f[1]),
        B = parseInt(f[2])
      return (
        'rgb(' +
            (Math.round((t - R) * p) + R) +
            ',' +
            (Math.round((t - G) * p) + G) +
            ',' +
            (Math.round((t - B) * p) + B) +
            ')'
      )
    }

    // .................. buildBranch - from branch end build new branch
    const buildTree = (tree, props={}) => {
      
      let length = props.length, 
      angle = props.angle, 
      depth = props.depth, 
      maxDepth = props.maxDepth, 
      branchWidth = props.branchWidth, 
      branchColor = props.branchColor, 
      maxAngleDelta = props.maxAngleDelta, 
      branchShrinkage = props.branchShrinkage, 
      directions = props.directions
      

      let step = Math.floor(depth)

      let newFeatures = []
      
      let treeSections = tree.features
      let qSections = treeSections.length


      let newDepth = Math.floor(depth - 1)   // depth: 2, 1, 0 , newDepth: 1, 0
      if (newDepth <= 0) { return tree }
      let newBranchWidth = branchWidth * branchShrinkage
      let newBranchColor = shadeRGBColor(branchColor, 0.1)

      

      
      for (let i=0; i<qSections; i++) {
        
        let section = treeSections[i]
        
        if (step <= qSections) {

          newFeatures.push(section)



        } else if (step >= qSections) {

          let newAngle = angle + maxAngleDelta * (Math.random() * 0.5)
          let newLength = length * (branchShrinkage + Math.random() * (1.0 - branchShrinkage))

          let x1 = branch[branch.length - 1][0]
          let y1 = branch[branch.length - 1][1]

          let newStems = directions
            .filter(d => true)
            .map(direction => {
              let dirAngle = newAngle + maxAngleDelta * (Math.random() * 0.5 * direction)
              let dirLength = newLength * (branchShrinkage + Math.random() * (1.0 - branchShrinkage))

              const x2 = x1 + dirLength * Math.cos(dirAngle)
              const y2 = y1 + dirLength * Math.sin(dirAngle)

              let newbranch = [...branch , [x2, y2] ]
              return newbranch

            })

          newFeatures = [...newFeatures, ...newStems]

        }
      }
      
      let newTree = {
            type: 'FeatureCollection', 
            features: newFeatures
          }
      return newTree

    }


    // .................. treeAni1
    let treeAni1 = {

      eohal: 'mars',

      eofold: ani => {

        let eoload = ani.eoload

        let feature = {
          type: 'Feature',
          geometry: { type: 'MultiLineString', coordinates: [] },
          properties: {},
        }


        const maxDepth = eoload.tree.maxDepth,
          depth = eoload.tree.depth,
          trunkWidth = eoload.tree.trunkWidth,
          branchColor = eoload.tree.branchColor,
          length = eoload.tree.length0,
          angle = eoload.tree.angle0,
          x0 = eoload.tree.x0,
          y0 = eoload.tree.y0,
          branchShrinkage = eoload.tree.branchShrinkage,
          maxAngleDelta = eoload.tree.maxAngleDelta,
          directions = eoload.tree.directions

        


        let uidPreitem = ani.eoric.uid
        let preAnigram = uidPreitem ? muonStore.findAnigramFromUid(uidPreitem) : null
        let tree
        if (preAnigram) {
          
          tree = preAnigram.eofold
          
        } else {
          
          let x1 = x0
          let y1 = y0
          let x2 = x1 + length * Math.cos(angle)
          let y2 = y1 + length * Math.sin(angle)
          let stemFeature = {
            type: 'Feature',
            geometry: {
              type: 'MultiLineString',
              coordinates: Array.of([ [x1, y1], [x2, y2] ]) // MultiLineString geometry
            }
          }  
          tree = {
            type: 'FeatureCollection', 
            features: Array.of(stemFeature, stemFeature, stemFeature)
          }

        }
        
  if (1 && 1) console.log('tree', tree)      
      let newtree = buildTree(tree, {length, angle, depth, maxDepth, trunkWidth, branchColor, maxAngleDelta, branchShrinkage, directions})
  if (1 && 1) console.log('newtree', newtree)  



        // feature.geometry.coordinates = tree
        // let newFeatureCollection = {type: 'FeatureCollection', features: []}
        // newFeatureCollection.features.push(feature)
        return newtree

      },

      eotim: eotim,
      eoric: { gid: 'ani', cid: 'ani', fid: 'ani1'},
      eocrom: {'csx': 0, 'cf': 555, 'cs': 777, 'cw': 0.9, 'co': 0.0072, 'cp': 0.7},

      eoload: {
        tree: {
          x0: -120,
          y0: -120,
          length0: 60,
          angle0: Math.PI / 2,

          directions: [-2, 0, 2],
          maxDepth: 7, // 11
          depth: [[[0, 7]]], // 11
          trunkWidth: 12,
          branchColor: 'rgb(101, 67, 33)',
          branchShrinkage: 0.7, // 0.8,
          maxAngleDelta: Math.PI / 2,
          delay: 10,

        },
      },
    }


    // .................. sceneAni
    let sceneAni = {

      eohal: 'scene',
      eofold: null,
      eotim: eotim,
      eoric: {gid: 'scene', cid: 'scene', fid: 'scene'},
      eoload: {
        context: {svg: 1, versor: 0, wen: 1, webgl: 0, bck: 1},
      },

    }

    // .................. animas
    let animas = [

      sceneAni, // h.scene
      treeAni1, // h.mars

    ]

    return animas
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>
