<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__mapper) {
  // .................. eons
  let [
    ctlWen,
    eohalMars,
    eohalSol,
    eohalScene,
  ] = await Promise.all([
    __mapper('xs').c('wen'),
    __mapper('xs').e('mars'),
    __mapper('xs').e('sol'),
    __mapper('xs').e('scene'),
  ])

  let muonStore = __mapper('muonStore')

  // .................. animas
  let ani = function () {
    // .................. pics
    let eotim = {'td': 3800, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}


    // .................. buildBranch - from branch end build new branch
    const buildTree = (tree, props={}) => {

      let length = props.length,
      angle = props.angle,
      depth = props.depth,
      maxDepth = props.maxDepth,
      branchWidth = props.branchWidth,
      branchColor = props.branchColor,
      maxAngleDelta = props.maxAngleDelta,
      branchShrinkage = props.branchShrinkage,
      directions = props.directions,
      eocrom = props.eocrom


      let step = Math.floor(depth)


      let treeFeatures = tree.features
      let qFeatures = treeFeatures.length

      let newFeatures = treeFeatures

      let newDepth = Math.floor(depth - 1)   // depth: 2, 1, 0 , newDepth: 1, 0
      if (newDepth <= 0) { return tree }




      for (let i=0; i<qFeatures; i++) {

        let feature = treeFeatures[i]

        if (step < qFeatures) {





          // newFeatures.push(feature)

        } else if (step >= qFeatures) {

          // ... step is above last current feature
          // ... linesInFeature in current feature geometry
          // ... new linesInFeature per current branch
          // ... for each line in Feature add new linesInFeature to end of current gen

          let linesInFeature = feature.geometry.coordinates  // pre-gen linesInFeature

          let linesInNewFeature = []

          for (let j=0; j<linesInFeature.length; j++) {

            let lineInFeature = linesInFeature[j]

            for (let k=0; k<directions.length; k++) {

              let direction = directions[k]

              // let newAngle = angle + maxAngleDelta * (Math.random() * 0.5)
              // let newLength = length * (branchShrinkage + Math.random() * (1.0 - branchShrinkage))

              let nodesInLine = lineInFeature.length
              let x1 = lineInFeature[nodesInLine - 1][0]
              let y1 = lineInFeature[nodesInLine - 1][1]


              let dirAngle = angle + maxAngleDelta * (Math.random() * 0.5 * direction)
              let dirLength = length * (Math.pow(branchShrinkage,i) + Math.random() * Math.pow((1.0 - branchShrinkage),i))


              const x2 = x1 + dirLength * Math.cos(dirAngle)
              const y2 = y1 + dirLength * Math.sin(dirAngle)

              let lineInNewFeature = [ [x1, y1] , [x2, y2] ]
              linesInNewFeature.push(lineInNewFeature)

            }

          }

          let neweocrom = {
            csx: 3,
            cf: 555,
            cs: eocrom.cs + 130 * i,
            cw: eocrom.cw * Math.pow(branchShrinkage, i),
            co: 0.0072,
            cp: 0.99,
          }

          let newFeature = {
            type: 'Feature',
            geometry: {
              type: "MultiLineString",
              coordinates: linesInNewFeature,
            },
            properties: {
              eocrom: neweocrom
            }
          }

          newFeatures = [...treeFeatures, newFeature]





        } else if (step === qFeatures) {

if (1 && 1) console.log('step', step)


          let linesInFeature = treeFeatures[step -1].geometry.coordinates  // pre-gen linesInFeature

          let linesInNewFeature = []

          for (let j=0; j<linesInFeature.length; j++) {

            let lineInFeature = linesInFeature[j]


              let direction = 0.1

              // let newAngle = angle + maxAngleDelta * (Math.random() * 0.5)
              // let newLength = length * (branchShrinkage + Math.random() * (1.0 - branchShrinkage))

              let nodesInLine = lineInFeature.length
              let x1 = lineInFeature[nodesInLine - 1][0]
              let y1 = lineInFeature[nodesInLine - 1][1]


              let dirAngle = angle + maxAngleDelta * (Math.random() * 0.5 * direction)
              
              let length = 0.1
              let dirLength = length * (Math.pow(branchShrinkage,i) + Math.random() * Math.pow((1.0 - branchShrinkage),i))


              const x2 = x1 + dirLength * Math.cos(dirAngle)
              const y2 = y1 + dirLength * Math.sin(dirAngle)

              linesInFeature[j] = [...lineInFeature, [x2, y2]]


          }


          newFeatures[step - 1] = feature
          newFeatures[step - 1].geometry.coordinates = linesInFeature


if (1 && 1) console.log('newFeatures', step, newFeatures)



        }



      }

      let newTree = {
            type: 'FeatureCollection',
            features: newFeatures
          }
      return newTree

    }


    // .................. treeAni1
    let treeAni1 = {

      eohal: 'mars',

      eofold: ani => {

        let eoload = ani.eoload
        let eocrom = ani.eocrom

        let feature = {
          type: 'Feature',
          geometry: { type: 'MultiLineString', coordinates: [] },
          properties: {},
        }


        const maxDepth = eoload.tree.maxDepth,
          depth = eoload.tree.depth,
          trunkWidth = eoload.tree.trunkWidth,
          branchColor = eoload.tree.branchColor,
          length = eoload.tree.length0,
          angle = eoload.tree.angle0,
          x0 = eoload.tree.x0,
          y0 = eoload.tree.y0,
          branchShrinkage = eoload.tree.branchShrinkage,
          maxAngleDelta = eoload.tree.maxAngleDelta,
          directions = eoload.tree.directions


        let uidPreitem = ani.eoric.uid
        let preAnigram = uidPreitem ? muonStore.findAnigramFromUid(uidPreitem) : null
        let tree
        if (preAnigram) {

          tree = preAnigram.eofold

        } else {
if (1 && 1) console.log('angle', angle)

          let x1 = x0
          let y1 = y0
          let x2 = x1 + length * Math.cos(angle)
          let y2 = y1 + length * Math.sin(angle)
          let stemFeature = {
            type: 'Feature',
            geometry: {
              type: 'MultiLineString',
              coordinates: Array.of([ [x1, y1], [x2, y2] ]) // MultiLineString
            }
          }
          tree = {
            type: 'FeatureCollection',
            features: Array.of(stemFeature),
            properties: ani.eoload.eocrom,
          }

        }
        let newtree = buildTree(tree, {length, angle, depth, maxDepth, trunkWidth, branchColor, maxAngleDelta, branchShrinkage, directions, eocrom})

        return newtree

      },

      eotim: eotim,
      eoric: { gid: 'ani', cid: 'ani', fid: 'ani1'},
      eocrom: {csx: 3, cf: 555, cs: 222, cw: 6.9, co: 0.0072, cp: 0.7},

      eoload: {
        tree: {
          x0: -0,
          y0: -160,
          length0: 60,
          angle0: Math.PI / 2,

          directions: [-2, 2],
          maxDepth: 8,
          depth: [[[0, 8]]],
          trunkWidth: 12,
          branchColor: [101, 67, 33],
          branchShrinkage: 0.9,
          maxAngleDelta: Math.PI / 2,
          delay: 10,

        },
      },
    }


    // .................. sceneAni
    let sceneAni = {

      eohal: 'scene',
      eofold: null,
      eotim: eotim,
      eoric: {gid: 'scene', cid: 'scene', fid: 'scene'},
      eoload: {
        context: {svg: 1, versor: 0, wen: 1, webgl: 0, bck: 1},
      },

    }

    // .................. animas
    let animas = [

      sceneAni, // h.scene
      treeAni1, // h.mars

    ]

    return animas
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>
