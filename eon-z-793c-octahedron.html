<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__eo) {
  let [
    d3,
    d3Geo,
    THREE,
    ctlWen,
    eohalMars,
    eohalTextform,    
    muonGeom,
    muonNatform,    
    muonNets,
    muonProps,
    renderPortview,
    renderSvg,
    renderWebgl,
  ] = await Promise.all([
    __eo('xs').b('d3'),
    __eo('xs').b('d3-geo'),
    __eo('xs').b('three'),
    __eo('xs').c('wen'),
    __eo('xs').e('mars'),
    __eo('xs').e('textform'),    
    __eo('xs').m('geom'),
    __eo('xs').m('natform'),    
    __eo('xs').m('nets'),
    __eo('xs').m('props'),
    __eo('xs').r('portview'),
    __eo('xs').r('svg'),
    __eo('xs').r('webgl'),
  ])

  let ani = function () {
  // .................. pics

    let epsilon = 1e-6, epsilon2 = epsilon * epsilon, asin = Math.asin
    let atan = Math.atan, abs = Math.abs
    let pi = Math.PI, degrees = 180 / pi, asin1_3 = Math.asin(1 / 3)
    let sqrt = Math.sqrt
    let theta = atan(0.5) * degrees,
      sin = Math.sin, cos = Math.cos 

    const eotim = {'td': 9800, 't0': 0, 't1': 1, 't2': 1, 't3': 1, nostop: 1}

    // http://netlib.org/polyhedra/
    // https://github.com/paaatrick/polyhedra-folding/blob/master/poly/0
    let def = `
:name
octahedron
:number
2
:symbol
{3,4}	@S sub 3 @
:dual
cube
:sfaces
8 8{3}
:svertices
6 6(@3 sup 4@)
:net
8 3
3 1 5 6
3 1 6 2
3 2 6 7
3 6 9 7
3 0 2 3
3 2 7 3
3 3 7 8
3 3 8 4
:solid
8 3
3 12 15 14
3 12 14 10
3 10 14 13
3 14 15 13
3 12 10 11
3 10 13 11
3 11 13 15
3 11 15 12
:hinges
7
0 2 1 0 1.9106332362490186
1 1 2 0 1.9106332362490186
2 1 3 2 1.9106332362490186
2 2 5 0 1.9106332362490186
4 1 5 2 1.9106332362490186
6 0 5 1 1.9106332362490186
7 0 6 2 1.9106332362490186
:dih
1
12 3 3 1.9106332362490185
:vertices
16 10
-1.44337567297406[(-5/6)*sqrt(3)] 1.5[3/2] 0[0]
-.577350269189626[(-1/3)*sqrt(3)] 0[0] 0[0]
-.577350269189626[(-1/3)*sqrt(3)] 1[1] 0[0]
-.577350269189626[(-1/3)*sqrt(3)] 2[2] 0[0]
-.577350269189626[(-1/3)*sqrt(3)] 3[3] 0[0]
.288675134594813[(1/6)*sqrt(3)] -.5[-1/2] 0[0]
.288675134594813[(1/6)*sqrt(3)] .5[1/2] 0[0]
.288675134594813[(1/6)*sqrt(3)] 1.5[3/2] 0[0]
.288675134594813[(1/6)*sqrt(3)] 2.5[5/2] 0[0]
1.15470053837925[(2/3)*sqrt(3)] 1[1] 0[0]
-.28867513459481281 2.5000000000000002 -1.6329931618554524
-3.8163916471489756e-17 2.0000000000000001 -.81649658092772641
-2.0122792321330962e-16 2.9999999999999991 -.81649658092772675
.57735026918962622 2.0000000000000002 -1.6329931618554525
.57735026918962629 3.0000000000000002 -1.6329931618554523
.86602540378443893 2.4999999999999999 -.81649658092772675
:EOF`

    // .................. facesAni anima
    let facesAni = {

      eohal: 'sol',
      eotim: eotim,
      eoric: {gid: 'facesAni', cid: 'facesAni', fid: 'facesAni'},

      eofold: anitem => {
        let tim = anitem.eoload.tim
        let faceColors = anitem.eoload.facecolors
        let lineColors = anitem.eoload.lineColors
        
        let net = muonNets.parse({text:def})
        
        
        
        let faces = net.faces
        for (let i=0; i<faces.length; i++) {
          let face = faces[i]
          
          
        }
        
        
        
        // let gj = {
          // type: 'Feature',
          // geometry: {
            // type: 'MultiPoint',
            // coordinates: net.verts,
          // },
          // properties: {
            // faces: net.faces,
            // hinges: net.hinges,
            // faceColors: faceColors,
            // lineColors: lineColors,
          // }
        // }
        
        // let t1, r, t2, m, u, c
          // t1 = new THREE.Matrix4()
          // r = new THREE.Matrix4()
          // t2 = new THREE.Matrix4()
          // m = new THREE.Matrix4()
          // t1.makeTranslation(-u.offset.x, -u.offset.y, -u.offset.z)
          // r.makeRotationAxis(u.axis, -that.amount * (Math.PI - u.amount)) // _e_ -y
          // t2.makeTranslation(u.offset.x, u.offset.y, u.offset.z)
          // m.multiplyMatrices(t2, r).multiply(t1)
          // obj.matrix = m        
        
        
        
        
        
        
        let threeObject = muonNets.duce({net, faceColors, lineColors})
        muonNets.update_matrices(threeObject, tim)

        let json = { // Feature
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [0, 0, 0] },
          properties: {
            object: threeObject,
            sort: 'threeobject',
          },
        }

        return json
      },

      eocrom: {'csx': 0, 'cf': [[[222, 333, 222, 333, 222, 333, 222]]], 'cs': 777, 'cw': 0.6, 'co': 0.999, 'cp': 0.999},

      eomot: {},
      eoload: {
        tim: [[[0,0,1]]],
        faceColors: [
          [ 0.9, 0.9, 0.3 ],
        ],
        lineColors: [
          [0.7,0.5,0.2],
        ],        
      },
    }

    // .................. cameraOrthoAni anima
    let cameraOrthoAni = {

      eotim: eotim,
      eoric: {gid: 'camera', cid: 'camera', fid: 'cameraOrthoAni'},
      eohal: 'sol',

      eofold: ani => {
        let json = {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [0, 0, 0] },
          properties: ani.eoload.properties,
        }
        return json
      },
      eoload: {
        properties: {
            sort: 'camera',
            type: 'OrthographicCamera',
            name: 'Orthographic',

            left: -2.0,
            right: 2.0,
            top: 2.0,
            bottom: -2.0,

            near: 0.001,
            far: 6,

            position: [0, 0, 2],
            rotation: [0, 0, 0],
            distance2nodesFactor: 10,
            lookAt: [0, 0, 0],
          },


      }
    }
  // .................. textAni
let net = muonNets.parse({text:def})

    let text = `(${net.number}) ${net.name}
symbol: ${net.symbol}
dual: ${net.dual}`

    let textsegment = function (text, t) {
      let s = text // source
      let a = Array.from(s) // discretize source
      let q = a.length // length, number of elems
      let n = Math.ceil(q * t) // elems in time
      let v = a.slice(0, n) // segment in time
      let s1 = v.join('') // rejoin segment

      return s1
    }
    let textAni = {
      eohal: 'textform',
      eotim: eotim,
      eoric: {gid: 'txtg', cid: 'txtcT', fid: 'txtfT'},

      eofold: ani => {
        let natipros = { eoform: ani.eoload.eoform, ghv: 1, gsa: 1, gco: 0 }
        return muonNatform.natMultiLineString(natipros)
      },
      eomot: {
        proform: {
          projection: 'uniwen',
          scale: [ 0.2, 0.2 ],

          translate: [ 0, 0, 0 ], // iter
          rotate: [0, 0, 0],
          lens: [0, 1, Infinity ],
        },
      },
      eocrom: { 'csx': 7, 'cf': 999, 'co': 0.9, 'cs': 999, 'cw': 0.1, 'cp': 0.99},

      eoload: {
        eoform: {
          x: {
            'm1': 4, 'm2': 4, 'n1': 2, 'n2': 2, 'n3': 2, 'a': 1, 'b': 1, // circ
            'ra2': 106, 'v0': 0, 'v1': 1, 'w4': 0, 'seg5': 18, 'pa6': 0, 'pb7': -1,
            'dom3': [ 0, 7 * 360 ],
            'fn0': (e, c) => e[0],
          },
          y: {
            'm1': 4, 'm2': 4, 'n1': 2, 'n2': 2, 'n3': 2, 'a': 1, 'b': 1, // circ
            'ra2': 106, 'v0': 0, 'v1': 1, 'w4': 0, 'seg5': 18, 'pa6': 0, 'pb7': -1,
            'dom3': [0, 360],
            'fn0': (e, c) => 0 * sin(e[0]),
          },
        },
        textform: {
          string: [[[function (t) {
            let txt = this.text
            let linenb = this.linenb
            let sttxt = txt.split('\n')
            return sttxt[linenb]
          }]]],
          text: text,
          style: {
            rotate: [[[ 0, 0 ]]],

            'font-size': [[[12, 12]]],
            'font-family': 'Verdana', // BankFuturistic, Arial
            // 'height': 56,
            'kerning': 4, // 1
            'lengthAdjust': 'spacing', // spacingAndGlyphs
            'letter-spacing': 1,
            'text-anchor': 'start', // start, middle, end
            'textLength': 0,
            // 'width': 111,
            'word-spacing': 1,
            // 'writing-mode': 'tb',
          },
        },
      },
    }

    let getanis = function (txt = '') {
      let anis = {}
      let a = txt.split('\n')
      for (let i = 0; i < a.length; i++) {
        let ani = muonProps.clone(textAni)
        ani.eoric.fid = textAni.eoric.fid + '_' + i
        ani.eoric.cid = textAni.eoric.cid + '_' + i
        ani.eomot.proform.translate = [75, -150 - 15 * i]
        ani.eoload.textform.linenb = i
        anis['ani' + '_' + i] = ani
      }
      return anis
    }

    // .................. scene
    let scene = Object.assign(
      {},
      getanis(text),
      {
      facesAni, // h.mars
      cameraOrthoAni, // h.sol
      }
    )

    return scene
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>