/**********************
 *    @eohalMelder
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)
    : typeof define === 'function' && define.amd ? define(['exports'], factory)
      : (factory((global.eohalMelder = global.eohalMelder || {})))
}(this, function (exports) {
  'use strict'

  async function eohalMelder (__mapper = {}) {
    let [
      muonEoric,
      muonGeom,
      ctlRayder,
      ctlWen,
      ctlVersor,
      eohalTurnform,
      muonStace,
      muonProps,
      muonProfier,
      muonProj3ct,
    ] = await Promise.all([
      __mapper('xs').m('eoric'),
      __mapper('xs').m('geom'),
      __mapper('xs').c('rayder'),
      __mapper('xs').c('wen'),
      __mapper('xs').c('versor'),
      __mapper('xs').e('turnform'),
      __mapper('xs').m('stace'),
      __mapper('xs').m('props'),
      __mapper('xs').m('profier'),
      __mapper('xs').m('proj3ct'),
    ])

    let muonStore = __mapper('muonStore')
    let rsvg = __mapper('renderSvg')

    // ............................. melder
    function eohalmelder (anitem) {
      let newItems = []

      let eohal = anitem.eohal,
        eoload = anitem.eoload,
        eoric = anitem.eoric,
        eotim = anitem.eotim

      let melder = eoload.melder || {}, // melder
        mousesignal = melder.mousesignal || 0, // mousesignal
        span = melder.span || 0, // span between paceitems
        geoaad = melder.geoaad || 0, // geoaad paceitem to previous anitem
        geosort = melder.geosort || 'anigram', // paceitem sort
        geoType = melder.geotype || 'LineString', //
        base = melder.geobase || 'eoform' //

      let uidAnima = muonEoric.getuid(eoric)
      let uidAnigram = muonEoric.getuid(eoric)
      let uidParent = anitem.parentuid
      let ricPreitem = (anitem.eoload.melder.eoric !== undefined)
        ? anitem.eoload.melder.eoric(anitem)
        : anitem.eoric
      let uidPreitem = muonEoric.getuid(ricPreitem)

      let animas = muonStore.animas()
      let anigrams = muonStore.anigrams()

      let anima = muonStore.findAnimaFromUid(uidAnima)

      // the anigram is the trace anigram

      let anigram = muonStore.findAnigramFromUid(uidAnigram)

      // the parent anima

      let parentAnima = uidParent ? muonStore.findAnimaFromUid(uidParent) : null

      let preAnima = uidPreitem ? muonStore.findAnimaFromUid(uidPreitem) : null

      if (1 && 1) console.log(' uidAnima ', uidAnima)
      if (1 && 1) console.log(' uidAnigram ', uidAnigram)
      if (1 && 1) console.log(' uidParent ', uidParent)
      if (1 && 1) console.log(' uidPreitem ', uidPreitem)

      if (1 && 1) console.log(' anima ', anima)
      if (1 && 1) console.log(' anigram ', anigram)
      if (1 && 1) console.log(' parentAnima ', parentAnima)
      if (1 && 1) console.log(' preAnima ', preAnima)

      // count: key:items pairs to be generated by melder
      let count = {}

      // if mouse up reset the controls on svg

      // if (ctlRayder.mouse() && ctlRayder.mouse().type === 'mouseup') {
      // ctlWen.reset(rsvg.svg())
      // ctlVersor.reset(rsvg.svg())
      // }

      // if mouse grabbed, enable event count, melder.eventN

      let grabbed = ctlRayder.grabbed()
      if (grabbed !== false) { //
        count.event = Math.floor(melder.eventN) // if in state or was event
        count.grabbed = grabbed
      }

      // init, melder.initN

      if (melder.eoinited === undefined || melder.eoinited !== 1) {
        count.init = Math.floor(melder.initN) // count INIT
      }

      // cycletime since last outed item, relevant if auto

      let cycletime = eotim.unitPassed - (melder.outed || 0)

      // if the cycletime is longer than auto pace
      //  and unitPassed is beyong autoT ...

      if (cycletime >= melder.autoP &&
            eotim.unitPassed > (melder.autoT || 0)
      ) {
        count.auto = Math.floor(melder.autoN) // count AUTO

        let paceanima
        if (anima !== undefined) {
          paceanima = anima // melder ir nanima
        } else {
          paceanima = parentanima // melder in avatar
        }

        // set eoinited: the anitem has started the melder

        paceanima.eoload.melder.eoinited = 1 //  eoinited

        // set melder.outed: item was outed at eotim.unitPassed time

        paceanima.eoload.melder.outed = eotim.unitPassed // updated with anima

        // if in auto mode, pace on each cycle
        // save anitem to preserve eoinited and outed

        let animas = Array.of(paceanima)

        // save anima .......... to persist eoinited and outed

        muonStore.apply({type: 'UPDANIMA', caller: 'h.melder', animas: animas})
      }

      // count: eg: {init:4, auto:1, event:3}
      if (Object.keys(count).length > 0) { // on pace count, eg {init: 6, auto: 1}
        // for each key in count

        for (let counter = 0; counter < Object.keys(count).length; counter++) {
          // key is the sort of count { init, auto, event }

          let key = Object.keys(count)[counter]

          // qitems is the number of items to be paced
          // generate qitems items of type key, eg. 6 (at init, on auto, when event)

          let qitems = count[key]

          // count, key, qitems, kq

          for (let i = 0; i < qitems; i++) {
            let props = { count: count, key: key, counter: i }

            let newItem

            if (anitem.eoload.melder.geosort === 'anima') {
              newItem = muonProps.clone(anima) // anima
            } else {
              newItem = muonProps.clone(anigram) // anigram
            }

            // if opt.add  type is LineString and geometry adds coords

            if (preAnima !== undefined) {
              // if exists, newItem builds from precursor

              newItem = preAnima

              // if (base !== undefined) { // geobase: {eoform, conform, ereform, proform}

              // console.assert(newItem.eofold.properties[base] !== undefined)
              // newItem.eofold.geometry = newItem.eofold.properties[base].geometry

              // }

              // if NO precursor, build from eoload and melder
              // eoload may carry all info of newItem but new eohal and pace count
              // properties in melder override those in eoload
            } else {
              newItem.eohal = anitem.eohal
              newItem.eoload = muonProps.clone(anitem.eoload)

              // if functional melder.eofold, override eofold

              if (anitem.eoload.melder.eofold !== undefined) {
                console.assert(typeof anitem.eoload.melder.eofold === 'function')
                newItem.eofold = anitem.eoload.melder.eofold(anitem)
              }
            }

            let situs = anitem.eoload.melder.stace(anitem, props)
            if (situs && typeof situs === 'object') situs = Object.values(situs)

            let coords = newItem.eofold.geometry.coordinates

            if (base === 'conform') {
              if (eofold.properties.conform) {
                coords = newItem.eofold.properties.conform.geometry.coordinates
              }
            } else if (base === 'ereform') {
              if (eofold.properties.ereform) {
                coords = newItem.eofold.properties.ereform.geometry.coordinates
              }
            } else if (base === 'proform') {
              if (eofold.properties.proform) {
                coords = newItem.eofold.properties.proform.geometry.coordinates
              }
            }

            if (coords && coords.length > 0) {
              let presitus = coords[coords.length - 1] // last point in paced string

              coords.push(situs)
            } else {
              coords = Array.of(situs) // coords start with first situs
            }

            newItem.eofold.geometry.coordinates = coords // upd coords

            let newItemsInCount = eohalTurnform.gramm(newItem) // h.turnform newItem
            newItems = [...newItems, ...newItemsInCount] // add new items
          }
        }
      }

      return newItems
    }

    // ............................. ween
    function ween (anitem) {
      if (1 && 1) console.log(' h.melder.ween', anitem)

      if (anitem.eoload.melder.geosort === 'anima') {
        return eohalmelder(anitem)
      } else {
        return Array.of(anitem)
      }
    }

    // ............................. gramm
    function gramm (anitem) {
      if (anitem.eoload.melder.geosort === 'anima') {
        return Array.of(anitem)
      } else {
        return eohalmelder(anitem)
      }
    }

    let eohal = {
      ween: anitem => ween(anitem),
      gramm: anitem => gramm(anitem),
    }

    // ....................... enty
    let enty = eohal

    return enty
  }

  exports.eohalMelder = eohalMelder
}))
