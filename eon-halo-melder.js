/**********************
 *    @haloMelder
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)
    : typeof define === 'function' && define.amd ? define(['exports'], factory)
      : (factory((global.haloMelder = global.haloMelder || {})))
}(this, function (exports) {
  'use strict'

  async function haloMelder (__mapper = {}) {
    let [
      muonRic,
      muonGeom,
      ctlRayder,
      ctlWen,
      ctlVersor,
      haloTurnform,
      muonStace,
      mprops,
      muonProfier,
      muonProj3ct,
    ] = await Promise.all([
      __mapper('xs').m('ric'),
      __mapper('xs').m('geom'),
      __mapper('xs').c('rayder'),
      __mapper('xs').c('wen'),
      __mapper('xs').c('versor'),
      __mapper('xs').h('turnform'),
      __mapper('xs').m('stace'),
      __mapper('xs').m('props'),
      __mapper('xs').m('profier'),
      __mapper('xs').m('proj3ct'),
    ])

    let muonStore = __mapper('muonStore')
    let rsvg = __mapper('renderSvg')

    // ............................. melder
    function halomelder (anitem) {
      let newItems = []

      let halo = anitem.halo,
        payload = anitem.payload,
        ric = anitem.ric,
        tim = anitem.tim

      let melder = payload.melder || {}, // melder
        mousesignal = melder.mousesignal || 0, // mousesignal
        span = melder.span || 0, // span between paceitems
        geoaad = melder.geoaad || 0, // geoaad paceitem to previous anitem
        geosort = melder.geosort || 'anigram', // paceitem sort
        geoType = melder.geotype || 'LineString', //
        base = melder.geobase || 'geoform' //

      let uidAnima = muonRic.getuid(ric)
      let uidAnigram = muonRic.getuid(ric)
      let uidParent = anitem.parentuid
      let ricPreitem = (anitem.payload.melder.ric !== undefined)
        ? anitem.payload.melder.ric(anitem)
        : anitem.ric
      let uidPreitem = muonRic.getuid(ricPreitem)

      let animas = muonStore.animas()
      let anigrams = muonStore.anigrams()

      let anima = muonStore.findAnimaFromUid(uidAnima)

      // the anigram is the trace anigram

      let anigram = muonStore.findAnigramFromUid(uidAnigram)

      // the parent anima

      let parentAnima = uidParent ? muonStore.findAnimaFromUid(uidParent) : null

      let preAnima = uidPreitem ? muonStore.findAnimaFromUid(uidPreitem) : null

      if (1 && 1) console.log(' uidAnima ', uidAnima)
      if (1 && 1) console.log(' uidAnigram ', uidAnigram)
      if (1 && 1) console.log(' uidParent ', uidParent)
      if (1 && 1) console.log(' uidPreitem ', uidPreitem)

      if (1 && 1) console.log(' anima ', anima)
      if (1 && 1) console.log(' anigram ', anigram)
      if (1 && 1) console.log(' parentAnima ', parentAnima)
      if (1 && 1) console.log(' preAnima ', preAnima)

      // count: key:items pairs to be generated by melder
      let count = {}

      // if mouse up reset the controls on svg

      // if (ctlRayder.mouse() && ctlRayder.mouse().type === 'mouseup') {
      // ctlWen.reset(rsvg.svg())
      // ctlVersor.reset(rsvg.svg())
      // }

      // if mouse grabbed, enable event count, melder.eventN

      let grabbed = ctlRayder.grabbed()
      if (grabbed !== false) { //
        count.event = Math.floor(melder.eventN) // if in state or was event
        count.grabbed = grabbed
      }

      // init, melder.initN

      if (melder.inited === undefined || melder.inited !== 1) {
        count.init = Math.floor(melder.initN) // count INIT
      }

      // cycletime since last outed item, relevant if auto

      let cycletime = tim.unitPassed - (melder.outed || 0)

      // if the cycletime is longer than auto pace
      //  and unitPassed is beyong autoT ...

      if (cycletime >= melder.autoP &&
            tim.unitPassed > (melder.autoT || 0)
      ) {
        count.auto = Math.floor(melder.autoN) // count AUTO

        let paceanima
        if (anima !== undefined) {
          paceanima = anima // melder ir nanima
        } else {
          paceanima = parentanima // melder in avatar
        }

        // set inited: the anitem has started the melder

        paceanima.payload.melder.inited = 1 //  inited

        // set melder.outed: item was outed at tim.unitPassed time

        paceanima.payload.melder.outed = tim.unitPassed // updated with anima

        // if in auto mode, pace on each cycle
        // save anitem to preserve inited and outed

        let animas = Array.of(paceanima)

        // save anima .......... to persist inited and outed

        muonStore.apply({type: 'UPDANIMA', caller: 'h.melder', animas: animas})
      }

      // count: eg: {init:4, auto:1, event:3}
      if (Object.keys(count).length > 0) { // on pace count, eg {init: 6, auto: 1}
        // for each key in count

        for (let counter = 0; counter < Object.keys(count).length; counter++) {
          // key is the sort of count { init, auto, event }

          let key = Object.keys(count)[counter]

          // qitems is the number of items to be paced
          // generate qitems items of type key, eg. 6 (at init, on auto, when event)

          let qitems = count[key]

          // count, key, qitems, kq

          for (let i = 0; i < qitems; i++) {
            let props = { count: count, key: key, counter: i }

            let newItem

            if (anitem.payload.melder.geosort === 'anima') {
              newItem = mprops.clone(anima) // anima
            } else {
              newItem = mprops.clone(anigram) // anigram
            }

            // if opt.add  type is LineString and geometry adds coords

            if (preAnima !== undefined) {
              // if exists, newItem builds from precursor

              newItem = preAnima

              // if (base !== undefined) { // geobase: {geoform, conform, ereform, proform}

              // console.assert(newItem.geofold.properties[base] !== undefined)
              // newItem.geofold.geometry = newItem.geofold.properties[base].geometry

              // }

              // if NO precursor, build from payload and melder
              // payload may carry all info of newItem but new halo and pace count
              // properties in melder override those in payload
            } else {
              newItem.halo = anitem.halo
              newItem.payload = mprops.clone(anitem.payload)

              // if functional melder.geofold, override geofold

              if (anitem.payload.melder.geofold !== undefined) {
                console.assert(typeof anitem.payload.melder.geofold === 'function')
                newItem.geofold = anitem.payload.melder.geofold(anitem)
              }
            }

            let situs = anitem.payload.melder.stace(anitem, props)
            if (situs && typeof situs === 'object') situs = Object.values(situs)

            let coords = newItem.geofold.geometry.coordinates

            if (base === 'conform') {
              if (geofold.properties.conform) {
                coords = newItem.geofold.properties.conform.geometry.coordinates
              }
            } else if (base === 'ereform') {
              if (geofold.properties.ereform) {
                coords = newItem.geofold.properties.ereform.geometry.coordinates
              }
            } else if (base === 'proform') {
              if (geofold.properties.proform) {
                coords = newItem.geofold.properties.proform.geometry.coordinates
              }
            }

            if (coords && coords.length > 0) {
              let presitus = coords[coords.length - 1] // last point in paced string

              coords.push(situs)
            } else {
              coords = Array.of(situs) // coords start with first situs
            }

            newItem.geofold.geometry.coordinates = coords // upd coords

            let newItemsInCount = haloTurnform.gramm(newItem) // h.turnform newItem
            newItems = [...newItems, ...newItemsInCount] // add new items
          }
        }
      }

      return newItems
    }

    // ............................. ween
    function ween (anitem) {
      if (1 && 1) console.log(' h.melder.ween', anitem)

      if (anitem.payload.melder.geosort === 'anima') {
        return halomelder(anitem)
      } else {
        return Array.of(anitem)
      }
    }

    // ............................. gramm
    function gramm (anitem) {
      if (anitem.payload.melder.geosort === 'anima') {
        return Array.of(anitem)
      } else {
        return halomelder(anitem)
      }
    }

    let halo = {
      ween: anitem => ween(anitem),
      gramm: anitem => gramm(anitem),
    }

    // ....................... enty
    let enty = halo

    return enty
  }

  exports.haloMelder = haloMelder
}))
