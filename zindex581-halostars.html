<!DOCTYPE html>
<meta charset="utf-8">
<title>animas</title>
<head >

  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    div#fps,svg { position: fixed; top:0; left:0; color: white; }
  </style>

</head>
<body style="cursor:crosshair"></body>
<div id="viewframe" class="viewframe"></div>

<script src='https://d3js.org/d3.v4.min.js'></script>
<script src='https://d3js.org/d3-geo.v1.min.js'></script>
<script src='https://d3js.org/d3-geo-projection.v2.min.js'></script>
<script src='https:////unpkg.com/d3-force-3d@1.0.7/build/d3-force-3d.bundle.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.0/topojson.min.js'></script>
<script src='https:////cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script>
<script src='https:////unpkg.com/three-trackballcontrols-web@0.0.2/dist/three-trackballcontrols.min.js'></script>
<script src="enls.js"></script>
<script src="ents.js"></script>

<script>

let muonAlima = function muonAlima(__mapper) {

  __mapper({"xs": xs.xs(__mapper)})               // PROXIES
  __mapper("xs").b("init")({svg:1,versor:0,wen:1,webgl:1})

  let f = __mapper({"props": muonProps.muonProps()}).props()
  let g = __mapper("xs").m("geom")
  let w = __mapper("xs").m("wen")

  /**********************
   *    @
   */
  let r = __mapper("xs").r("renderer"),
    width = r.width(),
    height = r.height()

  let rotInit = [0,45,0],
    rotation = [0,0,0],
    rotMatrix

  let versor = __mapper("xs").b("versor")()
  let wen = __mapper("xs").c("wen")({rotInit})

  /*******************************************
 *      @pics
 *
 */
  let tim = {"td":19800,"t0":0,"t1":1000,"t2":1,"t3":1,}

  let proform = {

    "projection": "uniwen",
    "translate":  [ 180 , 200],
    "scale": 90,
    "rotate": [-5,50,0], // [0,0,0], //
    "focale": 4,
    "zafin": [0,1], // [ [[[0,0,1,1,1,0]]], [[[0,0,1,1,1,0]]] ],  //
    "dims": 3,
    "control": "wen",
  }

  let payload = {

    rotBase:     [1,0,0,  0,1,0,  0,0,1],
    rotInit:     [0,0,0],
    velDecay:    0.95,
    velRot:      [1,0,0], //  [-6e-3, 7.6e-3, 2.13e-3],
    doxStar:     0 , // 1000, //  1,
    diStar:      1,
    maxZStar:    [[[2.5, 2.5]]],      // star passed
    hiStar:      10, // // [[[16,998]]], //   [[[4,4]]],
    focaleStar:       12 , // 100, //   0.1,
    velStar:     [[[0.05, 0.2]]]  , // [100,100], // [0.400, 0.400],
    boformStar:  { cf: 444, cs: 11, co: 0.99, cp: 1, },
    radioStar:   3,
    nbStars:     [[[6,24]]], // [[[24,24]]],  // 200


    points: [
      [-1, -1,  1],   // 0
      [ 1, -1,  1],   // 1
      [ 1, 1,   1],    // 2
      [-1, 1,   1],    // 3

      [-1, -1, -0],   // 5
      [ 1, -1, -0],   // 4
      [ 1, 1,  -0],    // 7
      [-1, 1,  -0],    // 6
     ],
    faces: [
      {
        pointsx: [0,1,2,3,0],
        name: "front",
        boform: {"csx":0,"cf":222,"cs":688,"cw":0.7,"co":[[[0.799,0.799]]],"cp":0.799,}},
      {
        pointsx: [4,5,6,7,4],
        name: "back",
        boform: {"csx":0,"cf":444,"cs":833,"cw":0.7,"co":[[[0.799,0.799]]],"cp":0.799,}},
      {
        pointsx: [1,5,6,2,1],
        name: "right",
        boform: { cf: 444, cs: 555, co: [[[0.2,0.2,0.2,0.2]]], cp: 1, }},
      {
        pointsx: [4,0,3,7,4],
        name: "left",
        boform: { cf: 555, cs: 655, co: [[[0.2,0.2,0.2,0.2]]], cp: 1, }},
      {
        pointsx: [3,2,6,7,3],
        name: "bottom",
        boform: { cf: 666, cs: 755, co: [[[0.9,0.9,0.9,0.9]]], cp: 1, }},
      {
        pointsx: [4,5,1,0,4],
        name: "top",
        boform: { cf: 777, cs: 855, co: [[[0.9,0.9,0.9,0.9]]], cp: 1, }}

    ],

  }
  /*******************************************
 *      @halo
 *
 */

    let stars = []

    // ............ newStar
    let newStar = function( p ) {
      let {dist, speed, focaleStar, bop, name} = p
      let star = Object.assign({}, p)
          star.x = (Math.random() - 0.5) * 1
          star.y = (Math.random() - 0.5) * 1
          star.z = dist
          star.speed = speed
          star.bop= bop
      return star
    }

    // ............ halogeoform
    let halogeoform = p => {
      let payload = p.payload,
          ric = p.ric,
          boform = p.boform

      let {nbStars, velStar, focaleStar, doxStar, maxZStar} = payload    // stars

      const dtMax = 1000 * 1 / 60
      let msPassed = p.tim.msPassed        // ms passed from first cycle
      let msDelta = p.tim.msDelta          // ms passed from previous cycle
      let dt = Math.max(msDelta , dtMax)  * 0.001


      if (stars.length < nbStars) {                     // CREATE

        for(let i = stars.length; i < nbStars; i++) {

          let dist = Math.random() * 0.2 // doxStar * Math.random() + 1

          let speed = velStar + Math.random() * velStar /2
          let bop = 1
          let name = "star_" + i

          let s = {dist, speed, focaleStar, bop, name }
          let star = newStar(s)

          stars.push(star)
        }
      }

      for (let i = 0, l = stars.length; i < l; i++) {   // UPD

        let star = stars[i]
        star.z = star.z + dt * star.speed      // z

        let starRange = maxZStar
        let bop = 0

        let s = {dist: doxStar, speed: velStar, focaleStar: focaleStar, bop, name: star.name}
        if (star.z > starRange || star.delled === 1) { // NEW STAR if out range or DELLED
          star = stars[i] = newStar(s)
        }

      }

      let jsonStars = {type: "FeatureCollection",features: []}
      for (let i = 0, l = stars.length; i < l; i++) {          // EACH STAR GEO

        let colorSpan = i * 10
        let star = stars[i]

        let geometry = {type:"Point",coordinates:[]}

        geometry.coordinates = Array.of( star.x, star.y, star.z )

        let feature = {type:"Feature",geometry:{},properties:{}}
          let _ric = {}
            _ric.gid = ric.gid
            _ric.cid = ric.cid + "star"
            _ric.fid = i

        feature.properties.zorder = star.z      // feature zorder from star z

        feature.properties.ric = _ric

        feature.properties.sort = "feature"
        feature.properties.pointRadius = payload.radioStar
        feature.geometry = geometry
        feature.properties.boform = boform    // same boform for all stars


        jsonStars.features.push(feature)

      }

      let jsonFaces = {type: "FeatureCollection", features: []}
      let {points, faces} = payload   // points faces

      for (let i = 0, l = faces.length; i < l; i++) {

        let face = faces[i]                // face pointsx position
        let geometry = {type:"Polygon",coordinates:[]}

        geometry.coordinates = Array.of(face.pointsx.map(k=>points[k])) // eg [-1, 1, 1]

        let feature = {type:"Feature",geometry:{},properties:{}}
          let _ric = {}
            _ric.gid = ric.gid
            _ric.cid = ric.cid + "face"
            _ric.fid = i
        feature.properties.ric = _ric

        feature.properties.sort = "feature"
        feature.geometry = geometry
        feature.properties.boform = face.boform || boform // boform per face
        jsonFaces.features.push(feature)
        
      }


      let json = {type: "FeatureCollection", features: []}
      json.features = [...jsonStars.features, ...jsonFaces.features] // merge features


      for (let i=0; i<json.features.length; i++) { // to same class to order from m.animate

        let feature = json.features[i]
        let _ric = {}
          _ric.gid = ric.gid
          _ric.cid = "ani"
          _ric.fid = (i,d,a) => _ric.cid + "_" + i  // svg count id
        feature.properties.ric = _ric

      }

      return json
    }

    // ............ gramnStars
    let gramnStars = function (anima, newAnigrams=[]) {

      let ani = __mapper("xs").m("anitem")(anima)

      let stace = ani.stace(),                // stace
        proform = ani.proform(),                // proform
        conform = ani.conform(),                // conform
        geoform = ani.geoform() || halogeoform     // geoform

      let json = (typeof geoform === "function") ? geoform(ani.anigram()) : geoform

      if (conform) {
        let conformer = __mapper("xs").m("profier")(conform)
        json =  __mapper("xs").b("proj3ct")(json, conformer)  // conform
      }

      if (stace) {
        let reformer = __mapper("xs").m("stace").getReform(stace)
        json =  __mapper("xs").b("proj3ct")(json, reformer)      // refform
      }

      if (proform) {
        let proformer = __mapper("xs").m("profier")(proform)
        json =  __mapper("xs").b("proj3ct")(json, proformer)  // proform
      }

      if (stace) {
        let lociformer =  __mapper("xs").m("stace").getLocifion(ani.anigram())
        json =  __mapper("xs").b("proj3ct")(json, lociformer)  // lociform
      }

      newAnigrams =  __mapper("xs").m("geoj").geojize(json, ani.anigram())  // id

      return newAnigrams
    }

    // ............ haloStars
    let haloStars = {}
        haloStars.ween = __mapper("xs").h("geojson").ween
        haloStars.gramn = anima => gramnStars(anima)

  /*******************************************
 *      @animas
 *
 */
// ------------------------- img
  let img = {

    "tim": tim,
    "ric": {"gid":"img","cid":"img","fid":"img",},
    "halo":"img",

    "boform": { "csx":0,"cf":[[[22,22]]],"cs":22,"cw":[[[0.7,0.7]]],"co":[[[0.7,0.7,]]],"cp":[[[0.5,0.5]]],},

    "geoform": p => ({
      type:  "Feature",
      geometry: {

        "type": "Point",
        "coordinates": [35, 40]

      },
      properties: {
        attr: {
          "width": p.payload.img.width,
          "height": p.payload.img.height,
          ["xlink:href"]: p.payload.img.url,
        }
      }
    }),

    "payload": {

      "img": {
        "url":"zimg-501.jpg",
        "width": [[[60, 60]]],
        "height": [[[40 , 40]]],
      },

    }
  }

  let aniCube = {

    "tim": tim,
    "ric": {"gid":"aniCube","cid":"aniCube","fid":"aniCube",},
    "halo":   haloStars,
    "boform":{ "csx":0,"cf":666,"cs":111,"cw":0.9,"co":0.9,"cp":0.9,},
    "proform": proform,
    "payload": payload,

  }

  let animas = [
    aniCube,  // haloStars g.uniwen
    img,      // h.img
  ]

  let animaApi = function animaApi() {
    __mapper("xs").m("store").apply({"type":"UPDANIMA","caller":"alima","animas":animas})
  }

  return animaApi

}

let __mapper = bosonMapper.bosonMapper()
__mapper({"muonAlima": muonAlima(__mapper)}).muonAlima(__mapper)
</script>
<body style="cursor:crosshair"></body>
