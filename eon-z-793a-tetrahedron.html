<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__eo) {
  let [
    d3,
    d3Geo,
    THREE,
    ctlWen,
    eohalMars,
    muonGeom,
    muonProps,
    renderPortview,
    renderWebgl,
  ] = await Promise.all([
    __eo('xs').b('d3'),
    __eo('xs').b('d3-geo'),
    __eo('xs').b('three'),
    __eo('xs').c('wen'),
    __eo('xs').e('mars'),
    __eo('xs').m('geom'),
    __eo('xs').m('props'),
    __eo('xs').r('portview'),
    __eo('xs').r('webgl'),
  ])

  let ani = function () {
  // .................. pics

    let epsilon = 1e-6, epsilon2 = epsilon * epsilon, asin = Math.asin
    let atan = Math.atan, abs = Math.abs
    let pi = Math.PI, degrees = 180 / pi, asin1_3 = Math.asin(1 / 3)
    let sqrt = Math.sqrt
    let theta = atan(0.5) * degrees

    const eotim = {'td': 9800, 't0': 0, 't1': 1, 't2': 1, 't3': 1, nostop: 1}

// http://netlib.org/polyhedra/
// https://github.com/paaatrick/polyhedra-folding/blob/master/poly/0
let def = `
:name
tetrahedron
:number
0
:symbol
{3,3}	@Y sub 3 @
:dual
tetrahedron
:sfaces
4 4{3}
:svertices
4 4(@3 sup 3@)
:net
4 3
3 1 2 4
3 3 1 4
3 1 0 2
3 4 2 5
:solid
4 3
3 7 9 8
3 6 7 8
3 7 6 9
3 8 9 6
:hinges
3
0 0 2 2 1.2309594173407747
0 1 3 0 1.2309594173407747
0 2 1 1 1.2309594173407747
:dih
1
6 3 3 1.2309594173407747
:vertices
10 6
-1[-1] -.577350269189626[(-1/3)*sqrt(3)] 0[0]
-.5[-1/2] .288675134594813[(1/6)*sqrt(3)] 0[0]
0[0] -.577350269189626[(-1/3)*sqrt(3)] 0[0]
0[0] 1.15470053837925[(2/3)*sqrt(3)] 0[0]
.5[1/2] .288675134594813[(1/6)*sqrt(3)] 0[0]
1[1] -.577350269189626[(-1/3)*sqrt(3)] 0[0]
-1.3333333333333333 -.76980035891950045 -1.0886621079036349
-.83333333333333384 -1.0584754935143137 -.27216552697590904
-.5000000000000002 -.28867513459481264 -.81649658092772612
-.44444444444444495 -1.2188505682892098 -1.1793839502289383
:EOF`

  let colors = [
    new THREE.Color().setHSL(0.00, 0.7, 0.5),
    new THREE.Color().setHSL(0.44, 0.7, 0.5),
    new THREE.Color().setHSL(0.88, 0.7, 0.5),
    new THREE.Color().setHSL(0.11, 0.7, 0.5),
    new THREE.Color().setHSL(0.55, 0.7, 0.5),
    new THREE.Color().setHSL(0.33, 0.7, 0.5),
    new THREE.Color().setHSL(0.77, 0.7, 0.5),
    new THREE.Color().setHSL(0.22, 0.7, 0.5),
  ]

// https://raw.githubusercontent.com/paaatrick/polyhedra-folding/master/js/PolyLoader.js
let parse = function (text) {
    var scope = this,
      verts = [],
      faces = [],
      hinges = [],
      lines = text.split('\n'),
      i = 0,
      line,
      nFaces,
      face,
      nHinges,
      nVerts,
      nums,
      j,
      k;

    function getLine(i) {
      return lines[i].trim();
    }

    while (i < lines.length) {
      line = getLine(i++);
      if (line === ":net") {
        line = getLine(i++);
        nFaces = parseInt(line.split(" ")[0], 10);
        for (j = 0; j < nFaces; j++) {
          line = getLine(i++).split(" ");
          face = [];
          for (k = 1; k < line.length; k++) {
            face.push(parseInt(line[k], 10));
          }
          faces.push(face);
        }
      } else if (line === ":hinges") {
        line = getLine(i++);
        nHinges = parseInt(line, 10);
        for (j = 0; j < nHinges; j++) {
          line = getLine(i++).split(" ");
          hinges.push([
            parseInt(line[0], 10),
            parseInt(line[1], 10),
            parseInt(line[2], 10),
            parseInt(line[3], 10),
            parseFloat(line[4])
          ]);
        }
      } else if (line === ":vertices") {
        line = getLine(i++);
        nums = line.split(" ");
        nVerts = parseInt(nums[nums.length - 1], 10);
        for (j = 0; j < nVerts; j++) {
          line = getLine(i++).replace(/\[.*?\]/g, "").split(" ");
          verts.push(new THREE.Vector3(
            parseFloat(line[0]),
            parseFloat(line[1]),
            parseFloat(line[2])
          ));
        }
      }
    }

    function cosAngle(v0, v1, v2) {
      var e1 = v0.clone().sub(v1),
        e2 = v2.clone().sub(v1);
      return e1.dot(e2) / (e1.length() * e2.length());
    }

    function starPentagonShape(face) {
      var amt,
        mid,
        shape = new THREE.Shape();
      amt = 2 / (3 + Math.sqrt(5));
      shape.moveTo(verts[face[0]].x, verts[face[0]].y);
      mid = verts[face[0]].clone().lerp(verts[face[1]], amt);
      shape.lineTo(mid.x, mid.y);

      shape.lineTo(verts[face[3]].x, verts[face[3]].y);
      mid = verts[face[3]].clone().lerp(verts[face[4]], amt);
      shape.lineTo(mid.x, mid.y);

      shape.lineTo(verts[face[1]].x, verts[face[1]].y);
      mid = verts[face[1]].clone().lerp(verts[face[2]], amt);
      shape.lineTo(mid.x, mid.y);

      shape.lineTo(verts[face[4]].x, verts[face[4]].y);
      mid = verts[face[4]].clone().lerp(verts[face[0]], amt);
      shape.lineTo(mid.x, mid.y);

      shape.lineTo(verts[face[2]].x, verts[face[2]].y);
      mid = verts[face[2]].clone().lerp(verts[face[3]], amt);
      shape.lineTo(mid.x, mid.y);

      return shape;
    }

    function regularShape(face) {
      var shape = new THREE.Shape(),
        m;
      shape.moveTo(verts[face[0]].x, verts[face[0]].y);
      for (m = 1; m < face.length; m++) {
        shape.lineTo(verts[face[m]].x, verts[face[m]].y);
      }
      return shape;
    }

    function build_tree(face, side, angle, parent) {

      side = (side === undefined) ? 0 : side;
      angle = (angle === undefined) ? Math.PI : angle;

      var parentName = (parent === undefined) ? -1 : parent.name,
        thisFace = faces[face],
        interiorAngle = cosAngle(verts[thisFace[0]],
                                 verts[thisFace[1]],
                                 verts[thisFace[2]]),
        node = new THREE.Object3D(),
        shape = regularShape(thisFace),
        mat = new THREE.MeshPhongMaterial({vertexColors: THREE.FaceColors}),
        ax = new THREE.Vector3(),
        s1 = thisFace[side],
        s2 = thisFace[(side + 1) % thisFace.length],
        hinge,
        n;

      // node.add(new THREE.Line(shape.createPointsGeometry()));
      // Line( geometry : Geometry, material : Material )
      let lineGeometry = new THREE.Geometry();
      lineGeometry.setFromPoints(shape.extractPoints().shape)
      node.add(new THREE.Line(lineGeometry))
      if (thisFace.length === 5 && interiorAngle > 0.5) {
        shape = starPentagonShape(thisFace); // star-pentagon special case
      }

      // var geo = shape.makeGeometry();
      var geo = new THREE.ShapeGeometry( shape );
      for (var i = 0; i < geo.faces.length; i++) {
        geo.faces[i].color = colors[thisFace.length - 3]; // scope : this
      }

      node.add(new THREE.Mesh(geo, mat));
      node.name = face;
      node.userData = {
        offset: verts[s1],
        axis: ax.subVectors(verts[s2], verts[s1]).clone().normalize(),
        amount: angle
      };
      if (parent !== undefined) {
        parent.add(node);
      }

      for (n = 0; n < hinges.length; n++) {
        hinge = hinges[n];
        if (hinge[0] === face && hinge[2] !== parentName) {
          build_tree(hinge[2], hinge[3], hinge[4], node);
        } else if (hinge[2] === face && hinge[0] !== parentName) {
          build_tree(hinge[0], hinge[1], hinge[4], node);
        }
      }
      return node;
    }
    return build_tree(hinges[0][0]);  // bject3DÂ 
  }




    // .................. facesAni anima
    let facesAni = {

      eohal: 'sol',
      eotim: eotim,
      eoric: {gid: 'facesAni', cid: 'facesAni', fid: 'facesAni'},

      eofold: anitem => {
        let threeObject = parse(def)


        let tim = anitem.eoload.tim

        var update_matrices = function (root, t=0) {
          
          let that = {}
          that.amount = t
        
          var t1, r, t2, m, u, c;
          if (root === undefined) {
            return;
          }
          root.traverse(function (obj) {
            u = obj.userData;
            if (u.hasOwnProperty("offset")) {
              t1 = new THREE.Matrix4();
              r = new THREE.Matrix4();
              t2 = new THREE.Matrix4();
              m = new THREE.Matrix4();
              t1.makeTranslation(-u.offset.x, -u.offset.y, -u.offset.z);
              r.makeRotationAxis(u.axis, - that.amount * (Math.PI - u.amount)); // _e_ -y
              t2.makeTranslation(u.offset.x, u.offset.y, u.offset.z);
              m.multiplyMatrices(t2, r).multiply(t1);
              obj.matrix = m;
              obj.matrixAutoUpdate = false;
              obj.matrixWorldNeedsUpdate = true;
            }
          });

          let target = new THREE.Vector3()
          c = new THREE.Box3().setFromObject(root).getCenter(target)
          root.matrix.multiply(new THREE.Matrix4().makeTranslation(-c.x, -c.y, -c.z));
          root.matrixAutoUpdate = false;
          root.matrixWorldNeedsUpdate = true;
          
          return root
        };        
        


        update_matrices(threeObject, tim)         
        
        let eoload = anitem.eoload
        let json = { // Feature
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [0,0,0], },
          properties: {
            object: threeObject,
            sort: 'threeobject',
          },
        }

        return json
      },

      eocrom: {'csx': 0, 'cf': [[[222, 333, 222, 333, 222, 333, 222]]], 'cs': 777, 'cw': 0.6, 'co': 0.999, 'cp': 0.999},

      eomot: {
        proform: {

          projection: 'uniwen',
          translate: [ 0, 0, 0 ],
          scale: [30, 30, 30],
          rotate: [[[[0, 6, 0]]], [[[0, 360]]], [[[0, 6, 0]]]],
          lens: [0, 1, Infinity ],

        },
      },
      eoload: {
        tim: [[[0,0,1]]]
      },
    }
    // .................. cameraPersAni anima
    let cameraPersAni = {

      eotim: eotim,
      eoric: {gid: 'camera', cid: 'camera', fid: 'cameraPersAni'},
      eohal: 'sol',

      eofold: anitem => {
        let eoload = anitem.eoload
        let json = { // Feature
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [0, 0, 0] },
          properties: {
            sort: 'camera',
            type: 'PerspectiveCamera',
            name: 'Perspective',
            fov: 90, // field of view s the field of view. angle in degrees.
            aspect: renderPortview.width() / renderPortview.height(),
            near: 0.001,
            far: 6,

            position: [0, 0, 1 ],
            rotation: [0, 0, 0 ],
            distance2nodesFactor: 100,
            lookAt: [0, 0, 0],
          },
        }
        return json
      },
    }
    // .................. cameraOrthoAni anima
    let cameraOrthoAni = {

      eotim: eotim,
      eoric: {gid: 'camera', cid: 'camera', fid: 'cameraOrthoAni'},
      eohal: 'sol',

      eofold: anitem => {
        let eoload = anitem.eoload
        let json = {
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [0, 0, 0] },
          properties: {
            sort: 'camera',
            type: 'OrthographicCamera',
            name: 'Orthographic',
            
            left:   -1,
            right:   1,
            top:     1,
            bottom: -1,
            
            near: 0.001,
            far: 6,

            position: [0, 0, 2],
            rotation: [0, 0, 0],
            distance2nodesFactor: 100,
            lookAt: [0, 0, 0],
          },
        }

        return json
      },

    }
    
    // .................. animas
    let animas = [

      facesAni, // h.mars
      // cameraPersAni, // h.sol
      cameraOrthoAni, // h.sol
    ]
    return animas
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>