/**********************
 *    @haloPacer
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)
    : typeof define === 'function' && define.amd ? define(['exports'], factory)
      : (factory((global.haloPacer = global.haloPacer || {})))
}(this, function (exports) {
  'use strict'

// # eon-halo-pacer
// **create new items at init, on auto or upon event**

// ### functions

// * ##### _geojsor
// usage: `_geojsor(@ani, @prob`
 // ani.pacer.initN
 // ani.pacer.eventN
 // ani.pacer.autoN
 // ani.pacer.autoP
 // ani.pacer.outtimed
 // ani.pacer.maxN
 // ani.pacer.span
	// ani.pacer.aad: {0,1} if 1, pace items are added to pacer (eg. LineString trace)
	// ani.pacer.type: {LineString}
	// ani.pacer.base: {geo, ere, pro}


// ### methods

// * ##### gramm
// `@a.p.pacer.initSitus`  : situs for init items
// `@a.p.pacer.autoSitus`  : situs for auto items, calls `m.stace.getLocus(this.stace, ani)`
// usage: `payload.pacer.autoSitus(anigram)`
// autositus in zindex: `function(a) {return mstace.getLocus(this.stace, ani) }` gets `ani.p.pacer.stance`
// auto time is `a.p.tim.unitPassed - a.p.pacer.outed`
// `@a.p.pacer.eventSitus` : situs for event items
// `count` new items to pacer from init, auto and event

// `@a.p.pacer.fidder`  : new item `fid` identifier
// `@a.p.pacer.geojsor(@anigram, @counter)` : gets new item

// ## license
// MIT


  async function haloPacer (__mapper = {}) {
    let [
      mric,
      mgeom,
      crayder,
      cwen,
      cversor,
      hent,
      mstace,
      mprops,
    ] = await Promise.all([
      __mapper('xs').m('ric'),
      __mapper('xs').m('geom'),
      __mapper('xs').c('rayder'),
      __mapper('xs').c('wen'),
      __mapper('xs').c('versor'),
      __mapper('xs').h('ent'),
      __mapper('xs').m('stace'),
      __mapper('xs').m('props'),
    ])

    let mstore = __mapper('muonStore')
    let rsvg = __mapper('renderSvg')

    // ............................. _geofolder
    let _geofolder = function (anitem, prob) {

      let pacer = anitem.payload.pacer

      let geoType = pacer.type || 'LineString',
        base = pacer.base || 'geo'

      // default geofold to LineString geo feature
      let geofold = {
        type: 'Feature',
        geometry: { type: geoType, coordinates: null },
        properties: {},
      }


      // get preexisting trace anitem
      let preani = mstore.findAnigramFromUid(anitem.payload.uid)


      console.assert(preani !== undefined, `anigram ${preani} is undefined`)

      // if there is a preani with a geofold ...
      if (preani !== undefined ) {
        
        // if preani has a geofold ...
        if (preani.geofold)  geofold = preani.geofold
        
          // on pacer.base .... set geofold.geometry
          if (base === 'geo') {
            if (geofold.properties.formGeoformed) { // revert geometry to formGeoformed
              geofold.geometry = geofold.properties.formGeoformed.geometry
            }
          } else if (base === 'ere') {
            if (geofold.properties.formEreformed) { // revert geometry to formEreformed
              geofold.geometry = geofold.properties.formEreformed.geometry
            }
          } else if (base === 'pro') {
            if (geofold.properties.formProformed) { // revert geometry to formProformed
              geofold.geometry = geofold.properties.formProformed.geometry
            }
          } else {
            if (geofold.properties.formGeoformed) { // revert geometry to formGeoformed
              geofold.geometry = geofold.properties.formGeoformed.geometry
            }
          }
      } else {
        
        // if preani does not exisit return default geofold
        
      }

      return geofold
    }

    // ............................. _stacer
    let _stacer = function (ani, props) {
      let stace
            if (props.key === 'init') {

              stace = {x: 0, y: 0, z: 0 }

            } else if (props.key === 'auto') {

              stace = mstace.getLocus(anitem.payload.pacer.stace, anitem)

            } else if (props.key === 'event') {

              stace = {x: crayder.grabbed()[0], y: crayder.grabbed()[1], z: 0 }

            }

      return stace
    }


   // ............................. pacer
    async function pacer (anitem) {
      let newItems = []

      let halo = anitem.halo,
        payload = anitem.payload,
        ric = payload.ric,
        tim = payload.tim

      let pacer = payload.pacer || {}, // pacer
        mousesignal = pacer.mousesignal || 0, // mousesignal
        span = pacer.span || 0, // span between items
        aad = pacer.aad || 0, // aad item to previous item
        itemsort = pacer.item || 'anigram' // pace items

      // count: key:items pairs to be generated by pacer
      let count = {}

      //  pacer interfaces: geofolder, stacer, riccer

      //
      // geofolder: geometry of the paced items
      // let geofolder = payload.pacer.geofolder || _geofolder
      let geofolder = _geofolder

      //
      // stacer: location of the paced items
      let stacer = payload.pacer.stacer ||  _stacer

      //
      // riccer: identity of the paced items. default to anitem.payload.ric
      let riccer = payload.pacer.riccer || function (ani) { return ani.payload.ric }

      //
      // if mouse up reset the controls on svg
      //
      if (crayder.mouse() && crayder.mouse().type === 'mouseup') { // if mouse up then reset

        cwen.reset(rsvg.svg())
        cversor.reset(rsvg.svg())

      }

      //
      // if mouse grabbed, enable event count, pacer.eventN
      if (crayder.grabbed()) { //

          count.event = Math.floor(pacer.eventN) //  if in state or was event

      }

      //
      //  init, pacer.initN
      if (pacer.inited === undefined || pacer.inited !== 1) {

        count.init = Math.floor(pacer.initN) // count INIT

      }

      //  auto
      // cycletime since last outed item
      let cycletime = tim.unitPassed - (pacer.outed || 0)

      // if the cycletime is longer than auto pace
      //  abd unitPassed is beyong autoT ...
      if (cycletime >= pacer.autoP &&
            tim.unitPassed > (pacer.autoT || 0)
      ) {

        count.auto = Math.floor(pacer.autoN) // count AUTO

        // set payload.inted: the anitem has started the pacer
        //
        anitem.payload.inited = 1 //  inited

        // set pacer.outed: item was outed at tim.unitPassed time
        //
        anitem.payload.pacer.outed = tim.unitPassed // updated with anima

        // if in auto mode, pace on each cycle
        // save anitem to preserve inited and outed
        //
        let anitems = Array.of(anitem)
        if (itemsort === 'anigram') {
          mstore.apply({type: 'UPDANIGRAM', caller: 'h.pacer', anigrams: anitems})
        } else if (itemsort === 'anima') {
          mstore.apply({type: 'UPDANIMA', caller: 'h.pacer', animas: anitems})
        }
      }
if (1 && 1) console.log('count', count)

      //
      // count: eg: {init:4, auto:1, event:3}
      //
      if (Object.keys(count).length > 0) { // on pace count, eg {init: 6, auto: 1}
        let stace // situs of new anitem dependent on kind

        // for each key in count
        for (let counter = 0; counter < Object.keys(count).length; counter++) { // in count

          // key is count sort, eg. { init, auto, event }
          let key = Object.keys(count)[counter]

          // value  is the number of items to be paced
          // generate qitems items of type key, eg. 6 (at init, on auto, when event)
          let qitems = count[key]

          // count, key, qitems, kq
          if (qitems> 0) { // if count on this sort
            for (let i=0; i<qitems; i++) {
                let props = {
                  count: count,
                  key: key,
                  counter: i
                }
                stace = stacer(anitem, props)
                let situs = mstace.getLocus(stace, anitem)
                if (situs && typeof situs === 'object') situs = Object.values(situs)


                // generated new item
                // halo is pacer.halo
                // geofold is from pacer.geofolder
                // payload inherits anitem.payload
                //
                let newItem = {}
                newItem.halo = halo
                newItem.geofold = geofolder(anitem)
                newItem.payload = Object.assign({}, anitem.payload) // newItem.payload
                newItem.payload.ric = riccer(anitem, props )
                newItem.payload.uid = mric.getuid(newItem.payload.ric)

                //
                // pacer.AAD
                // if pacer.add mode, new items add to pacer generated item (eg. segment point to LineString trace)
                //
                if (aad) {

                  //  add situs to newItem coords
                  //  coords are final space coords (after h.ent, stored at m.animation)
                  let coords = newItem.geofold.geometry.coordinates // domain coords
                  let geocoords = newItem.geofold.properties.geocoords // pre coords

                  if (coords && coords.length > 0) {
                    let presitus = coords[coords.length - 1] // last point in paced string

                    let d = mgeom.distance3d(presitus, situs) // distance to new coord
                    if (d >= span) {
                      coords.push(situs) // if beyond span ADD SITUS to LineString
                    }

                  } else {

                    coords = Array.of(situs) // coords start with first situs

                  }
if (1 && 1) console.log('coords', coords)

                  newItem.geofold.geometry.coordinates = coords // upd coords
                  newItem.geofold.properties.geocoords = geocoords

                  let newItemsInCount = await hent.gramm(newItem) // h.ent newItem
                  newItems = [...newItems, ...newItemsInCount] // add new items


                // NOT pacer.AAD
                // if not pacer.add, each pacer generated item
                //
                } else { //  if NOT aad

                  // if newItem geometry type is Point, then ...
                  //
                  if (newItem.geofold && newItem.geofold.geometry.type === 'Point') { // POINT

                    let presitus = newItem.geofold.geometry.coordinates

                    if (presitus !== null) { // if paced item DOES exist

                      let d = mgeom.distance3d(presitus, situs) // distance from previous situs

                      if (d >= span) { // if distance from previous point greater than span
                        newItem.geofold.geometry.coordinates = [0, 0, 0]
                        newItem.payload.proform = {projection: 'uniwen', translate: situs } // proform

                        // h.ent newItem
                        let newAnigrams = await hent.gramm(newItem) // process newItem as h.ent
                        newItems = [...newItems, ...newAnigrams] // add new anigrams
                      }

                    } else { // paced item does NOT exists

                      // newItem geofold
                      newItem.geofold.geometry.coordinates = [0, 0, 0]

                      // uniwen proform translater to situs
                      newItem.payload.proform = {projection: 'uniwen', translate: situs} // proform

                      // h.ent.gramm newItem point
                      let newGrams = await hent.gramm(newItem)
                      newItems = [...newItems, ...newGrams] // add items

                    }

                  // if the trace form of newItem is not point then call gramm of the newItem halo
                  } else { // ..... else TRACE NAT

                    let halo = newItem.halo

                    newItem.payload.proform = { projection: 'uniwen', translate: situs } // proform transfer trace situs to halo

                    let newGrams = await __mapper('xs').h(halo).gramm(newItem)
                    newItems = [...newItems, ...newGrams] // add items
                  }
                }
              }
          }
        }
      }
if (1 && 1) console.log(' ... newItems', newItems.length, newItems)

      return newItems
    }

    // ............................. ween
    function ween (anitem, newItems = []) {
      let halo = anitem.halo,
        payload = anitem.payload,
        ric = payload.ric,
        tim = payload.tim

      let pacer = payload.pacer || {}, // pacer
        mousesignal = pacer.mousesignal || 0, // mousesignal
        span = pacer.span || 0, // span between items
        aad = pacer.aad || 0, // aad item to previous item
        item = pacer.item || 'anigram' // pace items

      if (item === 'anigram') {

      } else {

      }

      return newItems
    }

    // ............................. gramm
    function gramm (anitem) {

      return pacer(anitem)

    }

    let haloPacerHalo = function () {}
    haloPacerHalo.ween = anima => ween(anima)
    haloPacerHalo.gramm = anima => gramm(anima)

    // ....................... enty
    let enty = haloPacerHalo

    return enty
  }

  exports.haloPacer = haloPacer
}))
