/**********************
 *    @haloPacer
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)
    : typeof define === 'function' && define.amd ? define(['exports'], factory)
      : (factory((global.haloPacer = global.haloPacer || {})))
}(this, function (exports) {
  'use strict'

  // # eon-halo-pacer
  // **create new items at init, on auto or upon event**

  // ### functions

  // * ##### _geojsor
  // usage: `_geojsor(@ani, @prob`
  // ani.pacer.initN
  // ani.pacer.eventN
  // ani.pacer.autoN
  // ani.pacer.autoP
  // ani.pacer.outtimed
  // ani.pacer.maxN
  // ani.pacer.span
  // ani.pacer.geoaad: {0,1} if 1, pace items are added to pacer (eg. LineString trace)
  // ani.pacer.type: {LineString}
  // ani.pacer.geobase: {geo, ere, pro}

  // ### methods

  // * ##### gramm
  // `@a.p.pacer.initSitus`  : situs for init items
  // `@a.p.pacer.autoSitus`  : situs for auto items, calls `m.stace.getLocus(this.stace, ani)`
  // usage: `payload.pacer.autoSitus(anigram)`
  // autositus in zindex: `function(a) {return muonStace.getLocus(this.stace, ani) }` gets `ani.p.pacer.stance`
  // auto time is `a.p.tim.unitPassed - a.p.pacer.outed`
  // `@a.p.pacer.eventSitus` : situs for event items
  // `count` new items to pacer from init, auto and event

  // `@a.p.pacer.fidder`  : new item `fid` identifier
  // `@a.p.pacer.geojsor(@anigram, @counter)` : gets new item

  // ## license
  // MIT

  async function haloPacer (__mapper = {}) {
    let [
      muonRic,
      muonGeom,
      ctlRayder,
      ctlWen,
      ctlVersor,
      haloEoform,
      muonStace,
      mprops,
      muonProfier,
      muonProj3ct,
    ] = await Promise.all([
      __mapper('xs').m('ric'),
      __mapper('xs').m('geom'),
      __mapper('xs').c('rayder'),
      __mapper('xs').c('wen'),
      __mapper('xs').c('versor'),
      __mapper('xs').h('eoform'),
      __mapper('xs').m('stace'),
      __mapper('xs').m('props'),
      __mapper('xs').m('profier'),
      __mapper('xs').m('proj3ct'),
    ])

    let mstore = __mapper('muonStore')
    let rsvg = __mapper('renderSvg')

    // ............................. pacer
    function halopacer (anitem) {
     
      let newItems = []

      let halo = anitem.halo,
        payload = anitem.payload,
        ric = anitem.ric,
        tim = anitem.tim

      let pacer = payload.pacer || {}, // pacer
        mousesignal = pacer.mousesignal || 0, // mousesignal
        span = pacer.span || 0, // span between paceitems
        geoaad = pacer.geoaad || 0, // geoaad paceitem to previous anitem
        geosort = pacer.geosort || 'anigram', // paceitem sort
        geoType = pacer.type || 'LineString', //
        base = pacer.geobase || 'geoform' //

      // 
        
        
      // count: key:items pairs to be generated by pacer
      let count = {}

      //
      // if mouse up reset the controls on svg
      //
      if (ctlRayder.mouse() && ctlRayder.mouse().type === 'mouseup') {
        ctlWen.reset(rsvg.svg())
        ctlVersor.reset(rsvg.svg())
      }

      // if mouse grabbed, enable event count, pacer.eventN
      let grabbed = ctlRayder.grabbed()
      if (grabbed !== false) { //
        count.event = Math.floor(pacer.eventN) //  if in state or was event
        count.grabbed = grabbed
      }

      // init, pacer.initN
      if (pacer.inited === undefined || pacer.inited !== 1) {
        count.init = Math.floor(pacer.initN) // count INIT
      }

      // cycletime since last outed item, relevant if auto
      let cycletime = tim.unitPassed - (pacer.outed || 0)

      // if the cycletime is longer than auto pace
      //  and unitPassed is beyong autoT ...

      if (cycletime >= pacer.autoP &&
            tim.unitPassed > (pacer.autoT || 0)
      ) {
        count.auto = Math.floor(pacer.autoN) // count AUTO

        // set inited: the anitem has started the pacer
        anitem.inited = 1 //  inited

        // set pacer.outed: item was outed at tim.unitPassed time

        anitem.payload.pacer.outed = tim.unitPassed // updated with anima

        // if in auto mode, pace on each cycle
        // save anitem to preserve inited and outed

        let anitems = Array.of(anitem)
   
        if (geosort === 'anigram') {

          // anigrams do not change state

        } else if (geosort === 'anima') {
          // save anima .......... to persist inited and outed
          mstore.apply({type: 'UPDANIMA', caller: 'h.pacer', animas: anitems})
        }
      }

      // count: eg: {init:4, auto:1, event:3}
      if (Object.keys(count).length > 0) { // on pace count, eg {init: 6, auto: 1}
        // for each key in count

        for (let counter = 0; counter < Object.keys(count).length; counter++) {
          // key is the sort of count { init, auto, event }

          let key = Object.keys(count)[counter]

          // qitems is the number of items to be paced
          // generate qitems items of type key, eg. 6 (at init, on auto, when event)

          let qitems = count[key]

          // count, key, qitems, kq

          for (let i = 0; i < qitems; i++) {
            let props = { count: count, key: key, counter: i }

            let newItem = mprops.clone(anitem) // INIT NEWITEM

            
            
            // if opt.add  type is LineString and geometry adds coords

            
            
            if (geoaad) { //  if AAD
            
              // the paced ric is defined dynamically in the pacer or inherited from the anitem.payload

              let ric = (anitem.payload.pacer.ric !== undefined)
                ? anitem.payload.pacer.ric(anitem, props)
                : anitem.ric
              let uid = muonRic.getuid(ric)
              // check if precursor of newAnitem already exists

              let preani = mstore.findAnigramFromUid(uid)
              if (preani !== undefined) {
                
                // if exists, newItem builds from precursor

                newItem = preani

                // if (base !== undefined) { // geobase: {geoform, conform, ereform, proform}

                // console.assert(newItem.geofold.properties[base] !== undefined)
                // newItem.geofold.geometry = newItem.geofold.properties[base].geometry

                // }

                // if NO precursor, build from payload and pacer
                // payload may carry all info of newItem but new halo and pace count
                // properties in pacer override those in payload
              } else {
                newItem.halo = anitem.halo
                newItem.payload = mprops.clone(anitem.payload)

                // if functional pacer.geofold, override geofold

                if (anitem.payload.pacer.geofold !== undefined) {
                  console.assert(typeof anitem.payload.pacer.geofold === 'function')
                  newItem.geofold = anitem.payload.pacer.geofold(anitem)
                }
              }

              let situs = anitem.payload.pacer.stace(anitem, props)
              if (situs && typeof situs === 'object') situs = Object.values(situs)

              let coords = newItem.geofold.geometry.coordinates

                if (base === 'conform') {
                  if (geofold.properties.conform) {
                    coords = newItem.geofold.properties.conform.geometry.coordinates
                  }
                } else if (base === 'ereform') {
                  if (geofold.properties.ereform) {
                    coords = newItem.geofold.properties.ereform.geometry.coordinates
                  }
                } else if (base === 'proform') {
                  if (geofold.properties.proform) {
                    coords = newItem.geofold.properties.proform.geometry.coordinates
                  }
                }
              
              
              
              if (coords && coords.length > 0) {
                let presitus = coords[coords.length - 1] // last point in paced string

                coords.push(situs)
              } else {
                coords = Array.of(situs) // coords start with first situs
              }

              newItem.geofold.geometry.coordinates = coords // upd coords

              let newItemsInCount = haloEoform.gramm(newItem) // h.eoform newItem
              newItems = [...newItems, ...newItemsInCount] // add new items

              
            } else { //  if NOT AAD

            
            
              // NOT pacer.AAD if not pacer.add, pacer generates anitems
              // geofold is Feature

              // complete newItem definition

              let ownProps = Object.getOwnPropertyNames(pacer)
              for (let prop of ownProps) {
                
                if (newItem[prop] !== undefined) {
                  let newpropval = mprops.v(pacer[prop], anitem, props)
                  newItem[prop] = newpropval
                }

              }

              let halo = __mapper(__mapper('xs').ceonize(newItem.halo, 'halo'))
              if (geosort === 'anima') {
                let newItemsInCount = mprops.a(halo.ween(newItem))
                newItems = [...newItems, ...newItemsInCount] // add items
              } else {
                let newItemsInCount = halo.gramm(newItem)
                newItems = [...newItems, ...newItemsInCount] // add items
                
              }
              
              
              
              
            }
          }
        }
      }

      return newItems
    }

    // ............................. ween
    function ween (anitem) {


      if (anitem.payload.pacer.geosort === 'anima') {
        let halo = anitem.halo,
          payload = anitem.payload,
          ric = anitem.ric,
          tim = anitem.tim

        let pacer = payload.pacer || {}, // pacer
          mousesignal = pacer.mousesignal || 0, // mousesignal
          span = pacer.span || 0, // span between items
          geoaad = pacer.geoaad || 0, // geoaad item to previous item
          geosort = pacer.geosort || 'anigram' // pace items
          
          return halopacer(anitem)
        
      } else {
        return anitem
      }

    }

    // ............................. gramm
    function gramm (anitem) {
      
      if (anitem.payload.pacer.geosort === 'anima') {
        
          return Array.of(anitem)

      } else {

          return halopacer(anitem)
      }
    }

    let halo = {
      ween: anitem => ween(anitem),
      gramm: anitem => gramm(anitem)
    }

    // ....................... enty
    let enty = halo

    return enty
  }

  exports.haloPacer = haloPacer
}))
