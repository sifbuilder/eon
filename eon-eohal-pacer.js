/**********************
 *    @eohalPacer
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)
    : typeof define === 'function' && define.amd ? define(['exports'], factory)
      : (factory((global.eohalPacer = global.eohalPacer || {})))
}(this, function (exports) {
  'use strict'

  //... # eon-eohal-pacer
  //... **create new items at init, on auto or upon event**
  //...
  //... ### functions
  //...
  //... * ##### _geojsor
  //... usage: `_geojsor(@ani, @prob`
  //... ani.pacer.initN
  //... ani.pacer.eventN
  //... ani.pacer.autoN
  //... ani.pacer.autoP
  //... ani.pacer.outtimed
  //... ani.pacer.maxN
  //... ani.pacer.geospan
  //... ani.pacer.geoaad: {0,1} if 1, pace items are added to pacer (eg. LineString trace)
  //... ani.pacer.geotype: {LineString}
  //... ani.pacer.geobase: {geo, ere, pro}
  //...
  //... ### methods
  //...
  //... * ##### gramm
  //... `@a.p.pacer.initSitus`  : situs for init items
  //... `@a.p.pacer.autoSitus`  : situs for auto items, calls `m.stace.getLocus(this.stace, ani)`
  //... usage: `eoload.pacer.autoSitus(anigram)`
  //... autositus in zindex: `function(a) {return muonStace.getLocus(this.stace, ani) }` gets `ani.p.pacer.stance`
  //... auto time is `a.p.eotim.unitPassed - a.p.pacer.eoouted`
  //... `@a.p.pacer.eventSitus` : situs for event items
  //... `count` new items to pacer from init, auto and event
  //...
  //... `@a.p.pacer.fidder`  : new item `fid` identifier
  //... `@a.p.pacer.geojsor(@anigram, @counter)` : gets new item
  //...
  //... ## license
  //... MIT

  async function eohalPacer (__mapper = {}) {
    let [
      ctlRayder,
      muonEoric,
      muonGeom,
      muonProps,
      muonGeoj,
    ] = await Promise.all([
      __mapper('xs').c('rayder'),
      __mapper('xs').m('eoric'),
      __mapper('xs').m('geom'),
      __mapper('xs').m('props'),
      __mapper('xs').m('geoj'),
    ])

    let muonStore = __mapper('muonStore')

    let state = {}

    // ............................. pacer
    function eohale (anitem) {
      let newItems = []

      let epsilon = 1e-3

      let eohal = anitem.eohal,
        eoload = anitem.eoload,
        eoric = anitem.eoric,
        eotim = anitem.eotim

      let pacer = eoload.pacer || {},
        geospan = pacer.geospan || epsilon,
        geoaad = pacer.geoaad || 0,
        geosort = pacer.geosort || 'anigram',
        geotype = pacer.geotype || 'LineString',
        geobase = pacer.geobase || 'eoform'

      let uidAnima = muonEoric.getuid(eoric)
      let uidAnigram = muonEoric.getuid(eoric)
      let uidParent = anitem.eoric.parentuid

      let ricPreitem = anitem.eoric
      let uidPreitem = muonEoric.getuid(ricPreitem)

      let animas = muonStore.animas()
      let anigrams = muonStore.anigrams()

      // anima.avatar(pacer)
      // anima(pacer)
      // pacer generates animas (geosort:animas) or anigrams (geosort:anigram)


      let anigram = anitem
      let parentAnima = uidParent ? muonStore.findAnimaFromUid(uidParent) : null
      let preAnima = uidPreitem ? muonStore.findAnimaFromUid(uidPreitem) : null
      let anima = muonStore.findAnimaFromUid(uidAnima)

      let pacerAnima
      if (anima !== undefined) {
        
        pacerAnima = anima // pacer is anima
        
      } else {
        
        pacerAnima = parentAnima // pacer in avatar
        
      }

      //... anima has pacer in eoload or in avatar
      console.assert(pacerAnima !== undefined)

      //... count: key:items pairs to be generated by pacer
      let count = {}

      //... if mouse grabbed, enable event count, pacer.eventN
      let grabbed = ctlRayder.grabbed()

      //... check distance to previous location
      let dist = state.grabbed === undefined
        ? Infinity
        : muonGeom.distance3d(state.grabbed, grabbed)

      if (grabbed && dist > geospan) { //
        state.grabbed = grabbed
        count.event = Math.floor(pacer.eventN) // if in state or was event
        count.grabbed = state.grabbed
      }

      //... pacer init (pacer.initN) if anima is not yet eoinited

      if (pacerAnima.eoinited === undefined || pacerAnima.eoinited[uidAnima] === undefined) {
        count.init = Math.floor(pacer.initN) // count INIT
      } else {

        // eonited

      }

      // cycletime since last eoouted item, relevant if auto

      let cycletime = eotim.unitPassed - (pacer.eoouted || 0)

      //... if the cycletime is longer than auto pace
      //...  and unitPassed is beyong autoT ...
      //...  then process autoT

      if (cycletime >= pacer.autoP &&
            eotim.unitPassed > (pacer.autoT || 0)
      ) {
        count.auto = Math.floor(pacer.autoN) // count AUTO

        //... pacerUid is the pacer anima uid

        let pacerUid = pacerAnima.eoric.uid

        //... if pacer is avatar, each is inited.
        //... eoinited is set per pacer

        pacerAnima.eoinited = (pacerAnima.eoinited === undefined)
          ? {[pacerUid]: eotim.unitPassed}
          : Object.assign(pacerAnima.eoinited, {[pacerUid]: eotim.unitPassed})

        //... set pacer.eoouted: item was eoouted at eotim.unitPassed time
        //... if in auto mode, pace on each cycle
        //... save anitem to preserve eoinited and eoouted

        pacerAnima.eoouted = (pacerAnima.eoouted === undefined)
          ? {[pacerUid]: eotim.unitPassed}
          : Object.assign(pacerAnima.eoouted, {[pacerUid]: eotim.unitPassed})
      }

      
      //... eocount
      //...   eg: {init:4, auto:1, event:3}
      //...   init runs once
      //...   auto runs on each cycle
      //...   event runs on mouse event

      
      if (Object.keys(count).length > 0) { // on pace count, eg {init: 6, auto: 1}
        for (let counter = 0; counter < Object.keys(count).length; counter++) {
          
          // key is the sort of count { init, auto, event }

          let key = Object.keys(count)[counter]

          // qitems is the number of items to be paced
          // generate qitems items of type key, eg. 6 (at init, on auto, when event)

          let qitems = count[key]

          // count, key, qitems, kq

          for (let i = 0; i < qitems; i++) {
            let props = {
              count: count,
              key: key,
              counter: i,
            }

            let newItem
            
            if (anitem.eoload.pacer.geosort === 'anima') {
              
              newItem = muonProps.clone(pacerAnima) // anima
              
            } else {
              
              newItem = muonProps.clone(anigram) // anigram
              
            }

            
            //... remove eoload from newItem

            delete newItem.eoload

            
            //... parentuid is the anima uid

            newItem.eoric.parentuid = uidAnima
            if (1 && 1) console.log('uidAnima', uidAnima)

            //... override newItem propeties with pacer functors

            let ownProps = Object.getOwnPropertyNames(pacer)
            for (let prop of ownProps) {
              if (newItem[prop] !== undefined) {
                let newpropval = muonProps.v(pacer[prop], anitem, props)
                newItem[prop] = newpropval
              }
            }
            if (1 && 1) console.log('newItem', newItem)


            //... anima is stored

            let eohal = __mapper(__mapper('xs').ceonize(newItem.eohal, 'eohal'))
            if (geosort === 'anima') {
              
              //... eohal.ween
              let newItemsInCount = eohal.ween(newItem)

              newItemsInCount = muonProps.a(newItemsInCount)
              newItems = [...newItems, ...newItemsInCount] // add items
              muonStore.apply({type: 'UPDANIMA', caller: 'h.pacer', animas: newItems})
              
            } else {
              
              //... eohal.gramm
              let newItemsInCount = muonProps.a(eohal.gramm(newItem))

              newItems = [...newItems, ...newItemsInCount] // add items
            }
          }
        }
      }
      return newItems
    }

    // ............................. ween
    function ween (anitem) {
      if (anitem.eoload.pacer.geosort === 'anima') {
        return eohale(anitem)
      } else {
        return Array.of(anitem)
      }
    }

    // ............................. gramm
    function gramm (anitem) {
      if (anitem.eoload.pacer.geosort === 'anima') {
        return Array.of(anitem)
      } else {
        return eohale(anitem)
      }
    }

    let eohal = {
      ween: anitem => ween(anitem),
      gramm: anitem => gramm(anitem),
    }

    // ....................... enty
    let enty = eohal
    enty.grabbed = _ => _ !== undefined ? state.grabbed = _ : state.grabbed

    return enty
  }

  exports.eohalPacer = eohalPacer
}))
