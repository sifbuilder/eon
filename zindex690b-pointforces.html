<!DOCTYPE html>
<meta charset="utf-8">
<title>animas</title>
<head >

  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    div#fps,svg { position: fixed; top:0; left:0; color: white; }
  </style>

</head>
<body style="cursor:crosshair"></body>
<div id="viewframe" class="viewframe"></div>

<script src="script-enls.js"></script>
<script src="script-ents.js"></script>

<script>

let muonAlima = function (__mapper) {
  __mapper({'xs': xs.xs(__mapper)}) // PROXIES
  __mapper('xs').m('init')({svg: 1, versor: 0, bck: 0, wen: 1, webgl: 0, key: 1}) // INIT

  let f = __mapper({'props': muonProps.muonProps()}).props(),
    mpacer = __mapper('xs').m('pacer'),
    mstore = __mapper('xs').m('store'),
    mric = __mapper('xs').m('ric'),
    crayder = __mapper('xs').c('rayder'),
    mforces = __mapper('xs').m('forces')   

  let d3_force = d3

  let r = __mapper('xs').r('renderport'),
    width = r.width(),
    height = r.height()

  /*******************************************
 *      @pics
 *
 */
  let tim = {'td': 52800, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}
  let boform = { csx: 0, cf: 777, cs: 222, cw: 1.7, co: 0.7, cp: 0.5}
  let geofold = {type: 'Feature', geometry: { type: 'Point', coordinates: [0, 0, 0]}, properties: {pointRadius: 6}}

  /*******************************************
 *      @animas
 *
 */
  // -------------------------------  nat1

  let haloIsolation_gramm = anima => [] // GRAMM

  let haloIsolation_ween = anima => { // WEEN
    animas = []

    animas = mpacer(anima.payload)
    if (animas.length > 0) {
      anima.payload.inited = 1 //
      anima.payload.gelded = 1 //
      anima.payload.pacer.outted = 1 // off

      let cycletime = anima.payload.tim.unitPassed - (anima.payload.pacer.outtimed || 0)
      if (cycletime >= anima.payload.pacer.autoP) {
        anima.payload.pacer.outtimed = anima.payload.tim.unitPassed
        anima.payload.pacer.outtimed = anima.payload.pacer.outtimed
      }

      let animas = Array.of(anima) // upd ANIMA
      __mapper('xs').m('store').apply({'type': 'UPDANIMA', 'caller': 'h.pacer', animas})
    }

    return animas
  }

  let haloIsolationHalo = {}
  haloIsolationHalo.ween = anima => haloIsolation_ween(anima)
  haloIsolationHalo.gramm = anima => haloIsolation_gramm(anima)

  let nat1 = {

    halo: haloIsolationHalo, // 'ent',

    geofold: geofold,

    payload: {
      tim: tim,
      ric: {'gid': 'nat', 'cid': 'nat', 'fid': 'natroot'},
      proform: {'projection': 'uniwen','translate': [0, 0, 0],'scale': 1,'rotate': [ 0, 0, 0 ],'lens': [0, 1, 12]},
      boform: boform,

      pacer: {
        initN: 0,eventN: 1,autoN: 2,autoP: 0.01,outtimed: 0,maxN: 60,span: 15 / 1400,

        // geojsor: (p, i, k) => {
        geojsor: (p, count) => {
          let newItems = []
          if (Object.keys(count).length > 0) { // on pace count
            for (let i = 0; i < Object.keys(count).length; i++) { // for each COUNT
              let key = Object.keys(count)[i] // count sort

              if (count[key] > 0) { // if count on this sort
                for (let j = 0; j < count[key]; j++) {
                  let _halo = 'ent' // set halo
                  let _geoform = { // define geofold
                    type: 'Feature',
                    geometry: {type: 'Point', coordinates: [0, 0, 0]},
                    properties: {}
                  }
                  let _payload = p // payload is inherited from anima

                  let anis = mstore.anigrams()
                    .filter(ani => ani.payload.ric.gid === _payload.ric.gid &&
                                    ani.payload.ric.cid === _payload.ric.cid).length

                  let _ric = {}
                  _ric.gid = 'nat'
                  _ric.cid = (j % 2) ? 'orange' : 'gold'
                  _ric.fid = 'nat' + (anis + j) // fidder

                  let _uid = mric.getuid(_ric) // uid

                  let newItem = mstore.findAnigramFromUid(_uid) // anigram DOES exist ??
                  if (newItem === undefined) { // if not, create new anigram
                    newItem = {}
                    newItem.halo = _halo // set halo
                    newItem.geofold = _geoform // set geofold
                    newItem.id = _uid // set id
                    newItem.payload = _payload // set payload
                    newItem.payload.ric = Object.assign({}, _ric) // set ric

                    newItem.payload.boform.cf = (j % 2) ? 999 : 222
                    newItem.payload.boform.cs = (j % 2) ? 999 : 222
                  }

                  let situs = [0, 0, 0]
                  if (key === 'event' && crayder.event() !== undefined) situs = [crayder.event().x, crayder.event().y, 0]
                  else if (key === 'init') situs = [0, 0, 0 ]
                  else if (key === 'auto') situs = [0, 0, 0 ]

                  newItem.payload.proform = {'projection': 'uniwen', 'translate': situs} // proform

                  newItems.push(f.cloneObj(newItem))
                }
              }
            }
          }


          return newItems
        }

      },

      geonode: {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [0, 0, 0]
        },
        properties: {
          orgen: [0, 0, 0],
          velin: [0, 0, 0],
          prevous: [0, 0, 0],
          geodelta: [0, 0, 0]
        }
      }

    }
  }

  /*******************************************
 *      @forces
 *
 */
  // force_energy
  let force_energy = { // aniForce
    properties: {
      alpha: 1,
      alphaMin: 0.001,
      alphaDecay: 0.1,
      alphaTarget: 0
    },

    'field': function field (params = {}) {
      let nodes = params.nodes
      let aniCompForces = []

      let forceParams = {
        'type': 'energy',
        'filter': d => true,
        'src': d3_force,
        'nodes': nodes
      }

      let field = {
        'key': 'energy',
        'force': __mapper('xs').m('forces')(forceParams)

      }

      aniCompForces.push(field)
      return aniCompForces
    }
  }

  // force_viscosity
  let force_viscosity = {
    properties: {
      velocityDecay: 0.01
    },

    field: function (params = {}) { // field.field
      let nodes = params.nodes // nodes

      let aniCompForces = []

      let forceParams = {
        'type': 'noforce',
        'filter': d => true,
        'nodes': nodes
      }

      let field = {
        'key': 'viscosity',
        'force': mforces(forceParams)
      }

      aniCompForces.push(field)

      return aniCompForces
    }
  }

  // force_manybody
  let force_manybody = { // aniForce
    'properties': {
      'charge': -1.9
    },

    'field': params => {
      let nodes = params.nodes
      let aniCompForces = []

      let charge = params.properties.charge

      let forceParams = {
        type: 'manyBody',
        strength: charge,
        filter: d => d.payload.ric.gid === 'nat',
        nodes: nodes
      }

      let force = params => {
        let strength = params.strength || (() => 0.1)
        let theta = params.theta || (() => 0.9)
        let distanceMin = params.distanceMin || 1
        let distanceMax = params.distanceMax || Infinity
        return d3_force.forceManyBody()
          .strength(strength)
          .theta(theta)
      }

      let field = {
        'key': 'charge',
        'force': force(forceParams)
      }
      aniCompForces.push(field)
      return aniCompForces
    }
  }

  // force_collide
  let force_collide = { // aniForce
    properties: {
      
      radius: 16
      
    },

    field: params => {
      let nodes = params.nodes
      let forces = []

      let charge = params.properties.charge

      let forceParams = {
        type: 'collide',
        strength: charge,
        filter: d => d.payload.ric.gid === 'nat',
        nodes: nodes
      }

      let force = params => {
        let strength = params.strength || 1
        let radius = params.radius || 1
        let iterations = params.iterations || 1
        return d3.forceCollide(radius)
          .strength(strength)
      }

      let field = {
        key: 'collide',
        force: force(forceParams)
      }

      forces.push(field)
      return forces
    }
  }

  // force_link
  let force_link = { // aniForce
    'properties': {
      'charge': -1.9
    },

    'field': params => {
      let nodes = params.nodes
      let aniCompForces = []

      let charge = params.properties.charge

      let forceParams = {
        type: 'link',
        strength: charge,
        filter: d => d.payload.ric.gid === 'nat',
        nodes: nodes
      }

      let force = params => {
        let nodes = params.nodes || []
        let links = params.links || []
        let id = params.id || (d => d.index)
        let distance = params.distance || 30
        let strength = params.strength || (() => 0.1)
        let iterations = params.iterations || 1
        let d3_force = d3
        return d3_force.forceLink(nodes)
          .id(id)
          .distance(distance)
          .links(links)
          .strength(strength)
          .iterations(iterations)
      }

      let field = {
        'key': 'link',
        'force': force(forceParams)
      }
      aniCompForces.push(field)
      return aniCompForces
    }
  }

  /*******************************************
 *        @animaApi
 *
 */
  nat1.payload.forces = {
    force_energy,
    force_viscosity,
    force_manybody,
    force_collide,
    force_link

  }

  let animas = [
    nat1 // h.ent
  ]

  let animaApi = function animaApi () {
    __mapper('xs').m('store').apply({'type': 'UPDANIMA', 'caller': 'alima', 'animas': animas})
  }

  return animaApi
}

let __mapper = muonMapper.muonMapper()
__mapper({'muonAlima': muonAlima(__mapper)}).muonAlima(__mapper)
</script>
<body style="cursor:crosshair"></body>
