<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__mapper) {
  // .................. eons
  let [
    rrenderport,
    muonGeoj,
    muonProj3ct,
    muonProfier,
    muonStace,
    muonRic,
    muonSvg,
    dlicht5,
    haloTurnform,
    haloScene,
  ] = await Promise.all([
    __mapper('xs').r('renderport'),
    __mapper('xs').m('geoj'),
    __mapper('xs').m('proj3ct'),
    __mapper('xs').m('profier'),
    __mapper('xs').m('stace'),
    __mapper('xs').m('ric'),
    __mapper('xs').m('svg'),
    __mapper('xs').d('licht5'),
    __mapper('xs').h('turnform'),
    __mapper('xs').h('scene'),
  ])

  let muonStore = __mapper('xs').m('store')

  // .................. animas
  let ani = function () {
    // .................. pics
    let tim = {'td': 43800, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}

    let svgdata = dlicht5.data()
    let extent = svgdata.viewBox.split(' ').map(d => parseInt(d))
    let x0 = extent[0], y0 = extent[1], x1 = extent[2], y1 = extent[3]

    let width = rrenderport.width(), height = rrenderport.height()

    let r0 = width / (x1 - x0)
    let r1 = height / (y1 - y0)
    let rx = Math.sign(r0) * Math.min(Math.abs(r0), Math.abs(r1))
    let ry = -Math.sign(r1) * Math.min(Math.abs(r0), Math.abs(r1))

    let dx = -(width - (x1 - x0)) / 2
    let dy = -(height - (y1 - y0)) / 2

    let gjdata = muonSvg.castels(svgdata, {start: 0, stop: 0.9, step: 0.091})

    let nb = muonGeoj.getCoordsLength(gjdata) // will show (nb * t) dots,  eg. 894

    let proform = {
      projection: 'uniwen',
      translate: [dx - 0, dy - 0, 0],
      scale: [rx * 0.2, ry * 0.2],
      rotate: [ 0, 0, 0 ],
      lens: [0, 1, Infinity],
    }

    let project = muonProfier.uniweon(proform)
    let geoData = muonProj3ct(gjdata, project)

    // .................. polyForm
    let polyForm = {

      halo: 'leaform',

      eofold: ani => {
        let anigram = ani, // anigram
          halo = ani.halo, // halo
          eofold = ani.eofold, // eofold
          payload = ani.payload // payload

        let unitElapsed = ani.tim.unitElapsed // unit time elapsed
        let t = ani.payload.tf(unitElapsed) || unitElapsed // time function

        let nbt = Math.ceil(nb * t)
        let csi = t => muonGeoj.getCoordsInRange(geoData, nbt)

        let coords = csi(t).geometry.coordinates

        let ngj = {
          type: 'Feature',
          geometry: { type: 'Polygon', coordinates: [] },
          properties: {
            eochrom: { 'csx': 0, 'cf': 666, 'cs': 111, 'cw': 0.8, 'co': 1, 'cp': 0.9},
          },
        }

        // md: a single line generates a LineString from muonProj3ct(geoData)
        if (geoData.geometry.type === 'LineString') ngj.geometry.coordinates = Array.of(coords)
        else if (geoData.geometry.type === 'MultiLineString') ngj.geometry.coordinates = coords
        else if (geoData.geometry.type === 'Polygon') ngj.geometry.coordinates = coords

        let rings = ngj.geometry.coordinates // rings in Polygon
        let newFeatureCollection = {type: 'FeatureCollection', features: []}

        for (let i = 0; i < rings.length; i++) {
          let ring = rings[i]
          let feature = {
            type: 'Feature',
            geometry: { type: 'Polygon', coordinates: [ring]},
            properties: {},
          }
          if (i < rings.length - 1) { // first
            feature.properties.eochrom = { 'csx': 0, 'cf': 555, 'cs': 111, 'cw': 0.8, 'co': 1, 'cp': 1}
          } else {
            feature.properties.eochrom = { 'csx': 0, 'cf': 555, 'cs': 111, 'cw': 0.8, 'co': 0.1, 'cp': 1}
          }

          newFeatureCollection.features.push(feature)
        }

        newFeatureCollection.features = Array.of(ngj)

        let geodata = newFeatureCollection

        if (payload.proform) {
          let proformion = muonProfier.proformion(anigram)
          newFeatureCollection = muonProj3ct(geodata, proformion)
        }

        return newFeatureCollection
      },

      tim: tim,
      ric: { gid: 'fouriers', cid: 'fouriers', fid: 'fourier'},
      eochrom: {'csx': 0, 'cf': 555, 'cs': 111, 'cw': 0.9, 'co': 0.72, 'cp': 0.7},
      payload: { // payload in polyForm
        tf: t => t,

      },
    }

    // .................. sceneAni
    let sceneAni = {

      halo: 'scene',
      eofold: null,
      tim: tim,
      ric: {gid: 'scene', cid: 'scene', fid: 'scene'},
      payload: {
        context: {svg: 1, versor: 0, wen: 1, webgl: 0, bck: 1},
      },

    }

    // .................. animas
    let animas = [

      polyForm, // h.leaform
      sceneAni, // h.scene

    ]

    return animas
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>
