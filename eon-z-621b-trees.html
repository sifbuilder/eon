<script src="eon-x-eonify.js"></script>
<script>
window.xEonify.eon({anitem, time: undefined})

// .................. anitem
async function anitem (__mapper) {
  // .................. eons
  let [
    ctlWen,
    eohalMars,
    eohalSol,
    eohalScene,
  ] = await Promise.all([
    __mapper('xs').c('wen'),
    __mapper('xs').e('mars'),
    __mapper('xs').e('sol'),
    __mapper('xs').e('scene'),
  ])

  let muonStore = __mapper('muonStore')

  // .................. animas
  let ani = function () {
    // .................. pics
    let eotim = {'td': 3800, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}


    // .................. buildBranch - from branch end build new branch
    const buildTree = (tree, props={}) => {

      let growunit = props.growunit,
      baseangle = props.baseangle,
      depth = props.depth,
      maxDepth = props.maxDepth,
      branchWidth = props.branchWidth,
      branchColor = props.branchColor,
      maxAngleDelta = props.maxAngleDelta,
      branchShrinkage = props.branchShrinkage,
      directions = props.directions,
      eocrom = props.eocrom,
      subgrow = props.subgrow,  
      subgrowunit = props.subgrowunit
      
      let secangfact = 6 // 

      let step = Math.floor(depth)  // growth orbital

      let treeFeatures = tree.features
      let qFeatures = treeFeatures.length

      let newFeatures = treeFeatures  // tree gens to newTree gens

      for (let i=0; i<qFeatures; i++) { // each gen :: feature

        let feature = treeFeatures[i]

        if (step >= qFeatures) {  // if ste is in or above generation

          let linesInFeature = feature.geometry.coordinates  // pre-gen linesInFeature

          let linesInNewFeature = []

          for (let j=0; j<linesInFeature.length; j++) { // each line is a branch in feature

            let lineInFeature = linesInFeature[j]
            
            for (let k=0; k<directions.length; k++) { // split

              let direction = directions[k]

              // ent >

              let nodesInLine = lineInFeature.length
              let x1 = lineInFeature[nodesInLine - 1][0]
              let y1 = lineInFeature[nodesInLine - 1][1]

              let dirAngle = baseangle + maxAngleDelta * (Math.random() * 0.5 * direction)
              let dirLength = growunit * (Math.pow(branchShrinkage,i) + Math.random() * Math.pow((1.0 - branchShrinkage),i))

              const x2 = x1 + dirLength * Math.cos(dirAngle)
              const y2 = y1 + dirLength * Math.sin(dirAngle)

              let lineInNewFeature = [ [x1, y1] , [x2, y2] ]
              linesInNewFeature.push(lineInNewFeature)
              
              // ent <

            }

          }

          let neweocrom = {
            csx: 3,
            cf: 555,
            cs: eocrom.cs + 100 * i,
            cw: eocrom.cw * Math.pow(branchShrinkage, i),
            co: 0.0072,
            cp: 0.99,
          }

          let newFeature = {
            type: 'Feature',
            geometry: {
              type: "MultiLineString",
              coordinates: linesInNewFeature,
            },
            properties: {
              eocrom: neweocrom
            }
          }

          
          newFeatures = [...treeFeatures, newFeature]


        } // split
      } // gen

      if (subgrow === 1 && step < newFeatures.length) {

        let feature = newFeatures[step]

        let i = step
        let linesInFeature = feature.geometry.coordinates  // pre-gen linesInFeature
        let linesInNewFeature = []

        for (let j=0; j<linesInFeature.length; j++) {

          let lineInFeature = linesInFeature[j]

          let directions = [0.1]

          for (let k=0; k<directions.length; k++) { // split
          
            let direction = directions[k]

            // ent >
            let nodesInLine = lineInFeature.length
            console.assert(nodesInLine >= 2, `error in line ${lineInFeature}`)

            let x0 = lineInFeature[nodesInLine - 2][0]
            let y0 = lineInFeature[nodesInLine - 2][1]     
   
            let x1 = lineInFeature[nodesInLine - 1][0]
            let y1 = lineInFeature[nodesInLine - 1][1]

            let inang = Math.atan2(y1-y0, x1-x0)
            let maxAngleDelta = Math.PI / secangfact

            let dirAngle = inang + maxAngleDelta * (Math.random() * 0.5 * direction)

            let dirLength = subgrowunit * (Math.pow(branchShrinkage,i) + Math.random() * Math.pow((1.0 - branchShrinkage),i))


            const x2 = x1 + dirLength * Math.cos(dirAngle)
            const y2 = y1 + dirLength * Math.sin(dirAngle)

            let updfeature = [...lineInFeature, [x2, y2]]
            
            linesInFeature[j] = updfeature
            // ent <
            
          }

        }


        newFeatures[step] = feature
        newFeatures[step].geometry.coordinates = linesInFeature

      }



      let newTree = {
            type: 'FeatureCollection',
            features: newFeatures
          }
      return newTree

    }


    // .................. treeAni1
    let treeAni1 = {

      eohal: 'mars',

      eofold: ani => {

        let eoload = ani.eoload
        let eocrom = ani.eocrom

        let feature = {
          type: 'Feature',
          geometry: { type: 'MultiLineString', coordinates: [] },
          properties: {},
        }

        const props = eoload.tree.props,
          x0 = eoload.tree.x0,
          y0 = eoload.tree.y0,
          growunit = eoload.tree.props.growunit,
          baseangle = eoload.tree.props.baseangle

        props.eocrom = eocrom

        let uidPreitem = ani.eoric.uid
        let preAnigram = uidPreitem ? muonStore.findAnigramFromUid(uidPreitem) : null
        let tree
        if (preAnigram) {

          tree = preAnigram.eofold

        } else {

        
          // ent >
          let x1 = x0
          let y1 = y0
          let x2 = x1 + growunit * Math.cos(baseangle)
          let y2 = y1 + growunit * Math.sin(baseangle)
          let stemFeature = {
            type: 'Feature',
            geometry: {
              type: 'MultiLineString',
              coordinates: Array.of([ [x1, y1], [x2, y2] ])
            }
          }
          // ent <
          
          
          tree = {
            type: 'FeatureCollection',
            features: Array.of(stemFeature),
            properties: ani.eoload.eocrom,
          }

        }
        let newtree = buildTree(tree, props, eocrom)

        return newtree

      },

      eotim: eotim,
      eoric: { gid: 'ani', cid: 'ani', fid: 'ani1'},
      eocrom: {csx: 3, cf: 555, cs: 111, cw: 6.9, co: 0.0072, cp: 0.99},

      eoload: {
        tree: {
          x0: 0,
          y0: -100,
          
          props: {
            depth: [[[0, 12]]], // depth iter
            
            growunit: 2, // rate of feature growth in tick
            baseangle: Math.PI / 2, // start angle
            maxAngleDelta: Math.PI / 2, // max abs ang delta
            directions: [-2, 2], // deviations
            growunit: 2, // rate of feature growth in tick
            
            
            trunkWidth: 12, // initial ent size
            branchShrinkage: 0.9, // size shrink
            
            subgrow: 1, // inside growth
            subgrowunit: 2, // rate of feature growth in tick
            secangfact: 6, // width of secondary deviation

            branchColor: [101, 67, 33], // --
            maxDepth: 8, // --
            delay: 10, // --
          },
        },
      },
    }


    // .................. sceneAni
    let sceneAni = {

      eohal: 'scene',
      eofold: null,
      eotim: eotim,
      eoric: {gid: 'scene', cid: 'scene', fid: 'scene'},
      eoload: {
        context: {svg: 1, webgl: 0, bck: 1},
      },

    }

    // .................. animas
    let animas = [

      sceneAni, // h.scene
      treeAni1, // h.mars

    ]

    return animas
  }

  let enty = () => {}
  enty.ani = ani
  return enty
}
</script>
