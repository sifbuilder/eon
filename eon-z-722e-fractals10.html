<!DOCTYPE html>
<meta charset="utf-8">
<title>animas</title>
<head >

  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    div#fps,svg { position: fixed; top:0; left:0; color: white; }
  </style>

</head>
<body style="cursor:crosshair"></body>
<div id="viewframe" class="viewframe"></div>

<script src="eon-x-d3-require.js"></script>
<script src="eon-x-mapper.js"></script>
<script src="eon-x-s.js"></script>

<script>

;(async function eon () {
  let __mapper = xMapper.xMapper() // init mapper
  __mapper({'xD3Require': xD3Require}) // map require
  __mapper({'xs': xs.xs(__mapper)}) // map x.s

  let muonStore = await __mapper('xs').m('store') // map store
  let muonAnimation = await __mapper('xs').m('animation') // map animation

  let xanimas = await zindex(__mapper)
  let animas = xanimas.animas() // get animas

  muonStore.apply({type: 'UPDANIMA', animas: animas}) // upd animas
  muonAnimation.animate() // animate
})()

// .................. zindex
async function zindex (__mapper) {
  // .................. eons
  let [
    mprops,
    cwen,
    cversor,
    Complex,
    mric,
    mstore,
    mstace,
  ] = await Promise.all([
    __mapper('xs').m('props'),
    __mapper('xs').c('wen'),
    __mapper('xs').c('versor'),
    __mapper('xs').l('complex'),
    __mapper('xs').m('ric'),
    __mapper('xs').m('store'),
    __mapper('xs').m('stace'),
  ])

  // .................. animas
  let animas = function () {
    // .................. pics

    const pi = Math.PI, pi2 = 2 * pi,
      turn = 2 * Math.PI // 360

    let getForm = function (params = {}) {
      let _NAME = params.name || 'anis'
      _ROW = params.row || 2,
      _COL = params.col || 2,
      _LEVEL = params.depth || 2,
      _CF = params.cf || (d => 222 * 1), // cfonlevel
      _SIDES = params.sides || 5,
      _RAD = params.rad || 90,
      PHASED = params.anginit || 0 // 0 internal, 180 extenal

      const cyclet = _LEVEL * _LEVEL * 1000

      const x0 = -150,
        dx = 150,
        y0 = -100,
        dy = 100

      let x = x0 + (_COL - 1) * dx,
        y = y0 + (_ROW - 1) * dy

      const signexp = d => Math.pow(-1, d)

      // .................. traceLine
      let traceLine = { // SUB-MARKS line trace

        halo: 'pacer',
        geofold: null,
        payload: {
          ric: {gid: 'traces', cid: 'traces', fid: 'traces'},
          boform: {'csx': 0, 'cf': 444, 'cs': 666, 'cw': 0.99, 'co': 0.4, 'cp': 0.99},

          pacer: { // aad for trace
            stace: {
              x: { pos: 0 },
              y: { pos: 0 },
              z: 0,
            },
            initN: 0, eventN: 0, autoN: 1, autoP: 0, outtimed: 0, maxN: 60, span: 0, aad: 1,
            autoSitus: function (a) {
              let r = mstace.getLocus(this.stace, a) // situs
              return r
            },
            fidder: a => a.payload.ric.fid,

            geojsor: function (a, i) {
              let ric = a.payload.ric // ric
              let uid = mric.getuid(ric)
              let gj = {
                halo: 'ent',
                geofold: {
                  type: 'Feature',
                  geometry: { type: 'LineString', coordinates: null },
                  properties: { doc: 'pacer' },
                },
                payload: {
                  uid: uid, id: uid, ric: ric,
                  // proform: this.proform
                  proform: { // proform in the geographic domain
                    projection: 'orthographic',
                    scale: 90,
                    prerotate: [[[ cversor.rotation ]]],
                    translate: [0, 0],
                    rotate: [ 0, 0 ],
                  },
                },
              }
              let newItem = mstore.findAnigramFromUid(uid) || gj
              if (newItem.geofold.properties.formEreformed) {
                newItem.geofold.geometry = newItem.geofold.properties.formEreformed.geometry
              }
              return newItem
            },
          },
        },
      }

      // md: sinus location in fractalForm.geofold.geometry.coordinates
      // md:   adding the lower fractal coeficients

      let fractalForm = {

        halo: 'ent',

        geofold: a => ({
          type: 'Feature',
          geometry: {
            type: 'Point',

            coordinates: Complex({re: 0, im: 0})
              .add(a.payload.fractal.coef(a)) // set on zcoef = (rad, ang)
              .toVector(),

          },
          properties: {
            pointRadius: a.payload.fractal.rad,
            geonode: {
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [0, 0]},
              properties: {orgen: [0, 0], velin: [0, 0], velang: [0, 0], prevous: [0, 0], geodelta: [0, 0]},
            },
          },
        }),

        payload: {

          tim: {'td': cyclet * _LEVEL, 't0': 0, 't1': 1000, 't2': 1, 't3': 1},
          ric: {'gid': _NAME, 'cid': _NAME, 'fid': _NAME},
          boform: {'csx': 0, 'cf': 555, 'cs': 333, 'cw': 0.9, 'co': 0.2, 'cp': 0.7},

          fractal: {}, // set coef

          proform: { projection: 'uniwen', scale: 1, translate: [ -0, 0 ], rotate: [ 0, 0 ] }, // identity

        },
      }

      // .................. create anis
      let anis = [] // initialize animas

      let radOnLevel = d => (d === 0) ? _RAD : _RAD / (Math.pow(2, d)) // amplitude of sinus (level)
      let zcoef = (rad, ang) => Complex({re: rad * Math.cos(ang), im: rad * Math.sin(ang)}) // complex number

      for (let level = 0; level < _LEVEL; level++) { // for each cycloid level
        anis[level] = mprops.cloneObj(anis[level - 1] || fractalForm) // anis h.nat

        anis[level].payload.ric = {gid: 'nat', cid: _NAME + level, fid: _NAME + level} // id

        // -------------- ans(level) ------------------
        anis[level].payload.fractal.an = [] // [0..._LEVEL)

        for (let j = 0; j < level; j++) {
          let ang
          if (0) {
            ang = (j === 0) ? [[[ 0, turn ]]] : [[[ 0, (1) ** (j) * (_SIDES - 1) ** (j) * turn ]]]
          } else if (0) {
            ang = (j === 0) ? [[[ 0, turn ]]] : [[[ 0, (-1) ** (j) * (_SIDES - 1) ** (j) * turn ]]]
          } else {
            ang = (j === 0) ? [[[ 0, turn ]]] : [[[ 0, (1 - _SIDES) ** (j) * turn ]]] // frequency
          }

          let rad = radOnLevel(j)
          anis[level].payload.fractal.an[j] = {rad, ang}
        }

        anis[level].payload.fractal.coef = d => { // fractal coef(level)
          let z = d.payload.fractal.an.reduce((p, q) => {
            let aj = zcoef(q.rad, q.ang) // zcoef from amplitude and phase
            return p.add(aj)
          }, Complex({re: 0, im: 0}))
          return z
        }

        anis[level].payload.fractal.rad = radOnLevel(level) // rad(level)
        anis[level].payload.boform.cf = _CF(level) // boform
        if (level === _LEVEL - 1) { // add image as avatar to root nat
          anis[level].avatars = []

          anis[level].avatars.push(traceLine) // push traceLine avatar to last cycloid
        }
      }

      return anis
    }

    animas = getForm({depth: 3, rad: 30, sides: 6, wbase: 1, anginit: 180, name: 'as12', row: 1, col: 2})

    return animas
  }

  let enty = () => {}
  enty.animas = animas
  return enty
}
</script>